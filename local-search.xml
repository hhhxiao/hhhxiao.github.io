<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ELF格式与程序运行的内存模型</title>
    <link href="/posts/9cee/"/>
    <url>/posts/9cee/</url>
    
    <content type="html"><![CDATA[<p>最近在复习一些操作系统相关的知识,而操作系统说白了就是为程序运行提供的环境的,和硬件直接接触的软件.现代操作系统要为程序提供一种虚拟环境,包括但不限于一个独立的地址空间,一个独立的虚拟CPU以及其他一些东西(如系统调用等).今天正好借这个机会来梳理一下程序的运行环境(主要是内存模型).</p><blockquote><p>下面的所有例子都已C语言为例,但是请注意,这只是一种较为场景的实现,而<strong>不是C语言标准的一部分</strong></p></blockquote><h2 id="程序运行的内存模型"><a href="#程序运行的内存模型" class="headerlink" title="程序运行的内存模型"></a>程序运行的内存模型</h2><h4 id="静态内存和动态内存"><a href="#静态内存和动态内存" class="headerlink" title="静态内存和动态内存"></a>静态内存和动态内存</h4><p>我们先从最简单的C语言程序开始,这个程序甚至没有main函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = a;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们仅从内存的角度来考虑问题(即不考虑编译器的寄存器优化的影响),这段代码在内存中的运行时可能是下面这样的:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">┌──────────┐<br>│<span class="hljs-keyword">a</span> (<span class="hljs-number">4</span><span class="hljs-keyword">bytes</span>)│<br>├──────────┤<br>│b (<span class="hljs-number">4</span><span class="hljs-keyword">bytes</span>)│<br>└──────────┘<br></code></pre></td></tr></table></figure><p>然后我们再稍微来点更复杂的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">strcut A&#123;<br> <span class="hljs-type">int</span> x;<br> <span class="hljs-type">char</span> c;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-title">x</span>[3];</span><br>  x[<span class="hljs-number">0</span>].x = <span class="hljs-number">12</span>;<br>  x[<span class="hljs-number">1</span>].c = <span class="hljs-string">&#x27;c&#x27;</span><br>  <span class="hljs-keyword">struct</span> A* p = x + <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>它在内存中的分布可能是这样的:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">┌─────────────┐<br>│x<span class="hljs-selector-attr">[0]</span> (<span class="hljs-number">8</span>bytes)│<br>├─────────────┤<br>│x<span class="hljs-selector-attr">[1]</span> (<span class="hljs-number">8</span>bytes)│<br>├─────────────┤<br>│x<span class="hljs-selector-attr">[2]</span> (<span class="hljs-number">8</span>bytes)│<br>├─────────────┤<br>│<span class="hljs-selector-tag">p</span>    (<span class="hljs-number">8</span>bytes)│<br>└─────────────┘<br></code></pre></td></tr></table></figure><p>不难发现一点,在上述的示例代码中,程序占用的内存空间是<strong>编译期</strong>可以算出来的,如第一个例子<code>a</code>和<code>b</code>变量就占据了固定的8bytes,而第一个例子一个数组+3个指针一共占据了24bytes.到此为止,我们不难想到,<strong>为了节省运行时的开销,如果我们让编译器在编译的时候就计算出来程序的内存布局(也就是怎么排布,占多少个字节).</strong></p><p>但遗憾的是,不是所有场景下我们都编译期间知道内存大小,再来看个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br><span class="hljs-type">int</span> *y = <span class="hljs-built_in">malloc</span>(x * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>如果继续使用我们上面的模型,那么它们在内存中的分布可能是这样的(让我们暂时忽略函数调用):</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">┌──────────────────────────┐<br>│x        (<span class="hljs-number">4</span>bytes)         │<br>├──────────────────────────┤<br>│y<span class="hljs-selector-attr">[0]</span>     (<span class="hljs-number">4</span>bytes)         │<br>├──────────────────────────┤<br>│y<span class="hljs-selector-attr">[1]</span>     (<span class="hljs-number">4</span>bytes)         │<br>├──────────────────────────┤<br>│...      (<span class="hljs-number">4</span> * (x-<span class="hljs-number">3</span>) bytes)│<br>├──────────────────────────┤<br>│y<span class="hljs-selector-attr">[x-1]</span>   (<span class="hljs-number">4</span>bytes)         │<br>└──────────────────────────┘<br></code></pre></td></tr></table></figure><p>上面这个例子就要占用<code>4 + x * 4</code>字节的空间,而且这个空间无法在编译期计算得出,因为<code>x</code>只有等到用户输入才知道,因此也就不能使用上述的编译期间计算的模型了.为了解决这个问题,现在普遍采用的是<strong>静态+动态两种方法同时使用的内存分配方案:</strong></p><ol><li>对于程序执行流中编译期能计算出来的大小,我们就直接在编译期分配好(也就是告诉操作系统需要多少内存),暂时称这算为静态内存区域</li><li>对于只有运行时才能算出来的大小,就使用一个额外的动态内存区域在运行时分配内存,而静态内存区域只需要存储指向这段内存的一个指针即可(<strong>请注意指针是能编译期算出来的</strong>)</li></ol><p>上面的说法有点抽象,还是以上面的代码举个例子,在使用静态+动态内存分配后,我们就可以使用如下的内存模型:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">                    ┌──────────────────────────┐<br>┌─────────────────┐         │y<span class="hljs-selector-attr">[0]</span>     (<span class="hljs-number">4</span>bytes)         │<br>│x        (<span class="hljs-number">4</span>bytes)│├──────────────────────────┤<br>├─────────────────┤│y<span class="hljs-selector-attr">[1]</span>     (<span class="hljs-number">4</span>bytes)         │<br>│y*       (<span class="hljs-number">8</span>bytes)│────────&gt;├──────────────────────────┤<br>└─────────────────┘         │...      (<span class="hljs-number">4</span> * (x-<span class="hljs-number">3</span>) bytes)│          <br>     静态内存区域        ├──────────────────────────┤<br>                   │y<span class="hljs-selector-attr">[x-1]</span>   (<span class="hljs-number">4</span>bytes)         │<br>                    └──────────────────────────┘<br>                    动态内存区域<br></code></pre></td></tr></table></figure><p>接下来来介绍所谓的<strong>静态内存区域</strong>和<strong>动态内存区域</strong>到底是怎样的.</p><h3 id="静态内存区域与栈"><a href="#静态内存区域与栈" class="headerlink" title="静态内存区域与栈"></a>静态内存区域与栈</h3><p>上述说的静态内存区域其实就是程序的<strong>运行栈</strong>至于为什么要叫栈,这就是程序的执行特征来决定的了:<strong>程序在运行的时候有大量的函数调用行为,而栈是用来描述这一行为最合适的数据结构</strong>:</p><p>下面有一个简单的例子:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span>()</span>&#123;<br><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;<br>b();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b</span> ()</span>&#123;<br> <span class="hljs-built_in">int</span> y = <span class="hljs-number">0</span>;<br>c();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">c</span>()</span>&#123;<br><span class="hljs-built_in">int</span> z = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们运行<code>a()</code>,当函数调用链到达d的时候,栈空间的排布是如下这样的:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lasso">┌────────────┐&lt;- <span class="hljs-built_in">stack</span> top<br>│context of a│<br>├────────────┤<br>│x  (<span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span>)│<br>├────────────┤<br>│context of b│<br>├────────────┤<br>│y  (<span class="hljs-number">4</span><span class="hljs-built_in">bytes</span>) │<br>├────────────┤<br>│context of c│<br>├────────────┤<br>│u (<span class="hljs-number">4</span><span class="hljs-built_in">bytes</span>)  │<br>│     │&lt;- <span class="hljs-built_in">stack</span> pointer<br></code></pre></td></tr></table></figure><p>每当有一个函数被调用的时候,编译器就将该函数的调用上下文(包括传入的参数,返回值,栈指针等信息)入栈(往下移动栈指针),然后开始分配该函数所需要的经验静态内存空间;每当一个函数返回的时候, 编译器就将当前栈分配的静态内存空间和调用上下文等信息回收(往上移动栈指针即可),这样就形成了完整的函数但用过程. 这里将函数的调用上下文和其分配的静态内存空间称之为<strong>栈帧</strong>,上述过程也可以简化成这样:</p><ol><li>函数调用就是往栈中推入栈帧</li><li>函数的返回就是往栈中回收栈帧</li></ol><p>至于调用上下文,它会存储部分调用函数传递给当前函数的参数(还有部分参数直接写在寄存器中,不经过栈内存,具体看相关ABI),当前的栈指针,预分配的返回值等信息.</p><h3 id="动态内存区域与堆"><a href="#动态内存区域与堆" class="headerlink" title="动态内存区域与堆"></a>动态内存区域与堆</h3><p>动态内存区域就是由操作系统管理的一块空闲的内存空间,当一个用户(进程)需要的时候,可以通过特定的系统调用(如经C语言封装的<code>malloc</code>)来分配一块指定大小的内存,并返回指向该内存的指针作为句柄.这段内存被申请后,就无法被其他的用户使用了,直到该用户手动告诉操作系统这段内存自己不需要了(表现在C语言内就是<code>free</code>函数).我们管这段内存叫做<strong>堆</strong>并不是说它用了堆数据结构,而是这就是一个约定俗成的叫法,没啥理由..</p><p>如何实现一个堆内存分配器也是需要研究的地方,由于不是本篇的主题,这里就不细讲了.</p><p>说到这里你也就明白了如下的问题:</p><ol><li><p>为什么不能在函数中返回静态数组,而需要动态内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> * <span class="hljs-title function_">get_array</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为<code>get_array</code>返回后<code>array</code>所在的栈帧就被回收了,而如果你使用动态内存分配,实际的数组其实在动态内存区域中,不会被栈帧的回收所影响.</p></li><li><p>为什么C++不支持VLA(变成数组,C语言支持),所谓的<code>VLA</code>就是栈内数组的长度只有在运行时才能确定,如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val_test</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br><span class="hljs-type">int</span> arr[a];<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显,这违背了我们讲的上述内存分配模型:运行时才能确定的内存大小应该在分配在堆中,而不能在栈中.</p></li></ol><h3 id="其他的内存模型"><a href="#其他的内存模型" class="headerlink" title="其他的内存模型"></a>其他的内存模型</h3><h4 id="静态数据区域"><a href="#静态数据区域" class="headerlink" title="静态数据区域"></a>静态数据区域</h4><p>你可能会注意到，并不是所有的变量都是声明在函数内的，如果直接将这样的变量分配到栈中，那么该分到栈的哪个地方呢，答案是哪都不去，编译器会这种类型的数据专门开几个分区如</p><ol><li><code>bss</code>用来存储未初始化的全局变量</li><li><code>data</code>和<code>rodata</code>分别用存储可读写以及只读的已初始化的全局变量</li></ol><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>如果你是C语言新手，看到这段代码你可能会迷惑:为什下面这算代码中的<code>str</code>在函数执行完成后不会析构，这是因为在C语言中字符串字面量的内容(在本例中代指<code>Hello world</code>这几个字符 )自身不会存在栈中，而是可能放在<code>.rodata</code>中(具体在哪视编译器而定)。只有指向它的占8bytes的指针<code>str</code>会被放在栈中，因此这段代码是能够正常运行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">get_str</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello world&quot;</span><br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整的内存模型"><a href="#完整的内存模型" class="headerlink" title="完整的内存模型"></a>完整的内存模型</h3><p>说了这么多后，我们可以介绍一个完整的程序运行的内存模型了，<strong>无论如何请注意:该模型并不是C语言标准的一部分，而是一种较为常见的实现</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">┌────────────────────┐<br>│stack frame <span class="hljs-selector-tag">main</span>    │<br>├────────────────────┤<br>│stack frame  <span class="hljs-number">1</span>      │<br>├────────────────────┤<br>│stack frame  <span class="hljs-number">2</span>      │<br>├────────────────────┤<br>│...                 │<br>├────────────────────┤<br>│                    │<br>├────────────────────┤<br>│<span class="hljs-built_in">heap</span>(dynamic memory)│<br>├────────────────────┤<br>│<span class="hljs-selector-class">.bss</span>                │<br>├────────────────────┤<br>│<span class="hljs-selector-class">.data</span>               │<br>├────────────────────┤<br>│<span class="hljs-selector-class">.rodata</span>             │<br>├────────────────────┤<br>│<span class="hljs-selector-class">.text</span>               │<br>└────────────────────┘<br></code></pre></td></tr></table></figure><p>这之中只有<code>.text</code>没有提过，其实<code>.text</code>就是存储编译器指令代码的地方，程序运行就是程序计数器<code>PC</code>在这部分内存中跑来跑去。</p><h2 id="ELF的文件结构"><a href="#ELF的文件结构" class="headerlink" title="ELF的文件结构"></a>ELF的文件结构</h2><p>说完了可执行文件的内存结构，接下来介绍以下编译后的程序和数据在磁盘中的结构。在Unix(或类)Unix操作系统中，可执行文件(<code>.out</code>或者无后缀)，静态(<code>.a</code>)或者动态库(<code>.so</code>)文件都具有相同的文件格式：ELF,全称为<code>Executable and Linkable Format</code>.ELF文件基本上由三个header和一堆<code>section</code>构成。三个header分别为<code>file-header</code>，<code>section-headers</code>以及<code>program-headers</code>.</p><ol><li><p>和一般的二进制文件一样，File-header就是文件的头部元数据，里面标识了文件最基本的一些元数据，使用<code>readelf -Wh a.out</code>可以读出一个elf文件的file header：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ELF</span> Header:<br>  <span class="hljs-attribute">Magic</span>:   <span class="hljs-number">7</span>f <span class="hljs-number">45</span> <span class="hljs-number">4</span>c <span class="hljs-number">46</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>  <span class="hljs-attribute">Class</span>:                             ELF64<br>  <span class="hljs-attribute">Data</span>:                              <span class="hljs-number">2</span>&#x27;s complement, little endian<br>  <span class="hljs-attribute">Version</span>:                           <span class="hljs-number">1</span> (current)<br>  <span class="hljs-attribute">OS</span>/ABI:                            UNIX - System V<br>  <span class="hljs-attribute">ABI</span> Version:                       <span class="hljs-number">0</span><br>  <span class="hljs-attribute">Type</span>:                              DYN (Shared object file)<br>  <span class="hljs-attribute">Machine</span>:                           Advanced Micro Devices X86-<span class="hljs-number">64</span><br>  <span class="hljs-attribute">Version</span>:                           <span class="hljs-number">0</span>x1<br>  <span class="hljs-attribute">Entry</span> point address:               <span class="hljs-number">0</span>x1050<br>  <span class="hljs-attribute">Start</span> of program headers:          <span class="hljs-number">64</span> (bytes into file)<br>  <span class="hljs-attribute">Start</span> of section headers:          <span class="hljs-number">12600</span> (bytes into file)<br>  <span class="hljs-attribute">Flags</span>:                             <span class="hljs-number">0</span>x0<br>  <span class="hljs-attribute">Size</span> of this header:               <span class="hljs-number">64</span> (bytes)<br>  <span class="hljs-attribute">Size</span> of program headers:           <span class="hljs-number">56</span> (bytes)<br>  <span class="hljs-attribute">Number</span> of program headers:         <span class="hljs-number">13</span><br>  <span class="hljs-attribute">Size</span> of section headers:           <span class="hljs-number">64</span> (bytes)<br>  <span class="hljs-attribute">Number</span> of section headers:         <span class="hljs-number">27</span><br>  <span class="hljs-attribute">Section</span> header string table index: <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>可以看到，头部包含了魔数，版本号，ABI,机器和指令集等信息。</p></li><li><p>Section-Header,这部分比较好理解，经过编译(可能还有链接)后程序由多个<code>section</code>组成，比如<code>.text</code>,<code>.rodata</code>等，注意这些<code>section</code>和第一节提到的内存布局有一定区别，当然也有相当大的联系.而Section-Header则定义了这些section的级别信息，如果位置，大小，权限等等。使用<code>readelf -WS a.out</code>可以读出<code>a.out</code>的Section-Header等信息，因此我们可以说<strong>Section-Header定义了section在磁盘中的格式</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tap">There are<span class="hljs-number"> 27 </span>section headers, starting at offset 0x3138:<br><br>Section Headers:<br>  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al<br>  [ 0]                   NULL           <span class="hljs-number"> 0000000000000000 </span>000000<span class="hljs-number"> 000000 </span>00     <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 0<br>  [ 1] .interp           PROGBITS       <span class="hljs-number"> 0000000000000318 </span>000318 00001c<span class="hljs-number"> 00 </span>  A <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 1<br>  [ 2] .note.gnu.property NOTE           <span class="hljs-number"> 0000000000000338 </span>000338<span class="hljs-number"> 000020 </span>00   A <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 8<br>  [ 3] .note.gnu.build-id NOTE           <span class="hljs-number"> 0000000000000358 </span>000358<span class="hljs-number"> 000024 </span>00   A <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 4<br>  [ 4] .note.ABI-tag     NOTE            000000000000037c 00037c<span class="hljs-number"> 000020 </span>00   A <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 4<br>  [ 5] .gnu.hash         GNU_HASH        00000000000003a0 0003a0<span class="hljs-number"> 000024 </span>00   A <span class="hljs-number"> 6 </span> <span class="hljs-number"> 0 </span> 8<br>  [ 6] .dynsym           DYNSYM          00000000000003c8 0003c8<span class="hljs-number"> 000090 </span>18   A <span class="hljs-number"> 7 </span> <span class="hljs-number"> 1 </span> 8<br>  [ 7] .dynstr           STRTAB         <span class="hljs-number"> 0000000000000458 </span>000458 00007d<span class="hljs-number"> 00 </span>  A <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 1<br>  [ 8] .gnu.version      VERSYM          00000000000004d6 0004d6 00000c<span class="hljs-number"> 02 </span>  A <span class="hljs-number"> 6 </span> <span class="hljs-number"> 0 </span> 2<br>  [ 9] .gnu.version_r    VERNEED         00000000000004e8 0004e8<span class="hljs-number"> 000020 </span>00   A <span class="hljs-number"> 7 </span> <span class="hljs-number"> 1 </span> 8<br>  [10] .rela.dyn         RELA           <span class="hljs-number"> 0000000000000508 </span>000508 0000c0<span class="hljs-number"> 18 </span>  A <span class="hljs-number"> 6 </span> <span class="hljs-number"> 0 </span> 8<br>  [11] .init             PROGBITS       <span class="hljs-number"> 0000000000001000 </span>001000 00001b<span class="hljs-number"> 00 </span> AX <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 4<br>  [12] .plt              PROGBITS       <span class="hljs-number"> 0000000000001020 </span>001020<span class="hljs-number"> 000010 </span>10  AX <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span>16<br>  [13] .plt.got          PROGBITS       <span class="hljs-number"> 0000000000001030 </span>001030<span class="hljs-number"> 000010 </span>10  AX <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span>16<br>  [14] .text             PROGBITS       <span class="hljs-number"> 0000000000001040 </span>001040<span class="hljs-number"> 000175 </span>00  AX <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span>16<br>  [15] .fini             PROGBITS        00000000000011b8 0011b8 00000d<span class="hljs-number"> 00 </span> AX <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 4<br>  [16] .rodata           PROGBITS       <span class="hljs-number"> 0000000000002000 </span>002000<span class="hljs-number"> 000004 </span>04  AM <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 4<br>  [17] .eh_frame_hdr     PROGBITS       <span class="hljs-number"> 0000000000002004 </span>002004 00003c<span class="hljs-number"> 00 </span>  A <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 4<br>  [18] .eh_frame         PROGBITS       <span class="hljs-number"> 0000000000002040 </span>002040 0000e8<span class="hljs-number"> 00 </span>  A <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 8<br>  [19] .init_array       INIT_ARRAY      0000000000003df0 002df0<span class="hljs-number"> 000008 </span>08  WA <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 8<br>  [20] .fini_array       FINI_ARRAY      0000000000003df8 002df8<span class="hljs-number"> 000008 </span>08  WA <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 8<br>  [21] .dynamic          DYNAMIC         0000000000003e00 002e00 0001c0<span class="hljs-number"> 10 </span> WA <span class="hljs-number"> 7 </span> <span class="hljs-number"> 0 </span> 8<br>  [22] .got              PROGBITS        0000000000003fc0 002fc0<span class="hljs-number"> 000040 </span>08  WA <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 8<br>  [23] .data             PROGBITS       <span class="hljs-number"> 0000000000004000 </span>003000<span class="hljs-number"> 000010 </span>00  WA <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 8<br>  [24] .bss              NOBITS         <span class="hljs-number"> 0000000000004010 </span>003010<span class="hljs-number"> 000008 </span>00  WA <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 1<br>  [25] .comment          PROGBITS       <span class="hljs-number"> 0000000000000000 </span>003010 00002b<span class="hljs-number"> 01 </span> MS <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 1<br>  [26] .shstrtab         STRTAB         <span class="hljs-number"> 0000000000000000 </span>00303b 0000fc<span class="hljs-number"> 00 </span>    <span class="hljs-number"> 0 </span> <span class="hljs-number"> 0 </span> 1<br>Key to Flags:<br>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>  L (link order), O (extra OS processing required), G (group), T (TLS),<br>  C (compressed), x (unknown), o (OS specific), E (exclude),<br>  l (large), p (processor specific)<br></code></pre></td></tr></table></figure><p>注意这里有相当多的<code>section</code>。</p></li><li><p>Program Header，这部分是由编译期和链接器共同生成的，它定义了一个可执行文件被加载到内存后的布局，也就是说第一节中的内存布局就是由这个Header定义的，使用<code>readelf -Wl a.out</code>可以读出<code>a.out</code>的内存布局信息：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dns">Program Headers:<br>  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align<br>  PHDR           <span class="hljs-number">0x000040</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000040</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000040</span> <span class="hljs-number">0x0002d8</span> <span class="hljs-number">0x0002d8</span> R   <span class="hljs-number">0</span>x8<br>  INTERP         <span class="hljs-number">0x000318</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000318</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000318</span> <span class="hljs-number">0</span>x00001c <span class="hljs-number">0</span>x00001c R   <span class="hljs-number">0</span>x1<br>      [Requesting program interpreter: /lib64/ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span>]<br>  LOAD           <span class="hljs-number">0x000000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span> <span class="hljs-number">0x0005c8</span> <span class="hljs-number">0x0005c8</span> R   <span class="hljs-number">0</span>x1000<br>  LOAD           <span class="hljs-number">0x001000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000001000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000001000</span> <span class="hljs-number">0x0001c5</span> <span class="hljs-number">0x0001c5</span> R E <span class="hljs-number">0</span>x1000<br>  LOAD           <span class="hljs-number">0x002000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000002000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000002000</span> <span class="hljs-number">0x000128</span> <span class="hljs-number">0x000128</span> R   <span class="hljs-number">0</span>x1000<br>  LOAD           <span class="hljs-number">0</span>x002df0 <span class="hljs-number">0</span>x0000000000003df0 <span class="hljs-number">0</span>x0000000000003df<span class="hljs-number">0 0x000220</span> <span class="hljs-number">0x000228</span> RW  <span class="hljs-number">0</span>x1000<br>  DYNAMIC        <span class="hljs-number">0x002e00</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000003e00</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000003e00</span> <span class="hljs-number">0x0001c0</span> <span class="hljs-number">0x0001c0</span> RW  <span class="hljs-number">0</span>x8<br>  NOTE           <span class="hljs-number">0x000338</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000338</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000338</span> <span class="hljs-number">0x000020</span> <span class="hljs-number">0x000020</span> R   <span class="hljs-number">0</span>x8<br>  NOTE           <span class="hljs-number">0x000358</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000358</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000358</span> <span class="hljs-number">0x000044</span> <span class="hljs-number">0x000044</span> R   <span class="hljs-number">0</span>x4<br>  GNU_PROPERTY   <span class="hljs-number">0x000338</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000338</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000338</span> <span class="hljs-number">0x000020</span> <span class="hljs-number">0x000020</span> R   <span class="hljs-number">0</span>x8<br>  GNU_EH_FRAME   <span class="hljs-number">0x002004</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000002004</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000002004</span> <span class="hljs-number">0</span>x00003c <span class="hljs-number">0</span>x00003c R   <span class="hljs-number">0</span>x4<br>  GNU_STACK      <span class="hljs-number">0x000000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span> <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span> <span class="hljs-number">0x000000</span> <span class="hljs-number">0x000000</span> RW  <span class="hljs-number">0</span>x10<br>  GNU_RELRO      <span class="hljs-number">0</span>x002df0 <span class="hljs-number">0</span>x0000000000003df0 <span class="hljs-number">0</span>x0000000000003df<span class="hljs-number">0 0x000210</span> <span class="hljs-number">0x000210</span> R   <span class="hljs-number">0</span>x1<br><br> Section to Segment mapping:<br>  Segment Sections...<br>   <span class="hljs-number">00</span><br>   <span class="hljs-number">01</span>     .interp<br>   <span class="hljs-number">02</span>     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn<br>   <span class="hljs-number">03</span>     .init .plt .plt.got .text .fini<br>   <span class="hljs-number">04</span>     .rodata .eh_frame_hdr .eh_frame<br>   <span class="hljs-number">05</span>     .init_array .fini_array .dynamic .got .data .bss<br>   <span class="hljs-number">06</span>     .dynamic<br>   <span class="hljs-number">07</span>     .note.gnu.property<br>   <span class="hljs-number">08</span>     .note.gnu.build-id .note.ABI-tag<br>   <span class="hljs-number">09</span>     .note.gnu.property<br>   <span class="hljs-number">10</span>     .eh_frame_hdr<br>   <span class="hljs-number">11</span><br>   <span class="hljs-number">12</span>     .init_array .fini_array .dynamic .got<br></code></pre></td></tr></table></figure><p>该命令的输出有两个部分，第一部分是一个表格,定义了内存中的每个段，下面简单介绍下这个表是什么意思：</p><ol><li>Offset: 该段在文件内的偏移量</li><li>VirtAddr: 该段被加载到进程地址空间后应当位于的虚拟地址</li><li>PhysAddr: 如果目标硬件没有虚拟内存机制而使用的物理内存，那么该字段就定义了一个段被加载到内存中的物理地址</li></ol><p>第二步是是段<code>Segment</code>和<code>section</code>的对应关系，我们以<code>04</code>段为例，这个段包含了<code>.rodata .eh_frame_hdr .eh_frame</code>这三个secion</p></li></ol><p>在三个headers后就是每个section的具体内容了，其内部的内容有数据，代码以及一些调试信息等等，具体细节我也不够清晰，因此也不分析了。</p><p>简单总结下：</p><ol><li><code>elf</code>文件内部有多个section和两个主要的header</li><li>section-header记录了每个section的基本信息以及其在文件内的位置和大小</li><li>program-header则记录了每个segment和section的对应关系，以及每个segment在内存中排布规则</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单介绍C++中的Promise和Future</title>
    <link href="/posts/565e/"/>
    <url>/posts/565e/</url>
    
    <content type="html"><![CDATA[<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>随着计算机硬件的发展，单核芯片的性能已经很难再提升，现在科研和工程领域已经向着多核迈进很久了。这里先不说科研领域目前很火的分布式技术（包括存储、数据块，容器，网络等），而是从基本的工程领域的编程的视角上看，如何利用现代CPU的多核性能。</p><p>现代操作系统中CPU调度的基本单位是线程，在多核CPU的场景下多个线程会被操作系统调度器自动分配到多个核心中运行，如果线程数超过CPU的核心数(有的CPU具有超线程技术，这时候应该以最大超线程数为准)，那么调度器的一种可能的调度就是把这些线程平均分到多个核心上。</p><p>说了这么多，这里首先介绍下怎么在<code>C++11</code>或者以后的版本中怎么使用<code>&lt;thread&gt;</code>来进行多线程编程</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>下图创建了两个线程t1和t2,它们分别将x自增10000次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">            ++x;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)</span></span><br><span class="hljs-params"><span class="hljs-function">            ++x;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of x is %d&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你对计算机有一定认识的话就不难发现，运行完成后<code>x</code>的值极有可能不是<code>20000</code>,因为这两个线程之间存在竞争关系。计算机的内存只有一块，但是线程运行在两个不同的核心中，而<code>++x</code>操作不是原子操作，这会导致出现读脏数据，写失效等等问题，下面是一个可能的输出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Value of x <span class="hljs-keyword">is</span> <span class="hljs-number">13446</span><br></code></pre></td></tr></table></figure><h3 id="互斥与Mutex"><a href="#互斥与Mutex" class="headerlink" title="互斥与Mutex"></a>互斥与Mutex</h3><p>为了解决上述问题，CPU提供了一些基本的原子操作的原语(即一些特殊的指令)如<code>compare_and_exchange</code>或者<code>fetch_and_add</code>等来保证对一个变量的原子访问，在此基础上使用一些软件技巧，就有了互斥锁mutex。</p><p>mutex的基本作用就是对一个变量进行加锁，说简单就是：</p><ol><li>一个变量未被加锁的时候所有线程都可访问改变量</li><li>当一个线程在访问这个变量的期间，它就持有了这个变量的锁，此时其他线程如果想访问这个变量就必须阻塞直到这个线程释放这个锁</li><li>当线程访问变量结束后就可以释放锁，这时候其他线程就能继续抢占锁然后访问了，以此类推</li></ol><p>下面举了一个C++ mutex基本使用方法的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    std::mutex m;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            m.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            ++x;</span></span><br><span class="hljs-params"><span class="hljs-function">            m.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            m.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">            ++x;</span></span><br><span class="hljs-params"><span class="hljs-function">            m.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of x is %d&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种写法下x的值就一定是20000了，当然这里也可以利用C++引以为豪的<code>RAII</code>机制，使用<code>lock_gruard</code>来简化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::lock_guard&lt;std::mutex&gt; l(m);</span></span><br><span class="hljs-params"><span class="hljs-function">        ++x;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br></code></pre></td></tr></table></figure><p>原理和上面的<code>lock</code>+<code>unlock</code>是一样的，这里只是在构造函数内执行<code>lock</code>，在析构函数内执行<code>unlock</code>罢了。</p><h3 id="同步与condition-variable-条件变量"><a href="#同步与condition-variable-条件变量" class="headerlink" title="同步与condition_variable(条件变量)"></a>同步与<code>condition_variable</code>(条件变量)</h3><p>线程之前除了上述的互斥关系外，还有一层同步关系，有个典型的例子就是生产者消费者模型，生产者线程A必须在队列没满的时候才往里面加东西，消费者B必须只能在队列不为空的时候从里面拿东西，否者就一直阻塞。仔细分析的话就会发现这里有个”等待关系”或者说”条件关系”，比如A线程睡眠<strong>直到</strong>队列不满等。这也就是我们所说的同步。</p><p>可以使用条件变量来实现线程之间的同步，<code>condition_variable</code>也是基于CPU提供的一些基本的原语来实现，这里就不细究了。仔细对比下<code>condition_variable</code>和<code>mutex</code>，你会发现它们之前的一些共同点：</p><ol><li>两者都是某些线程能够执行，某些线程阻塞</li><li>两种都是执行完成的线程通知阻塞的线程</li></ol><p>为了演示条件变量的用法，这里使用一个简单线程池来展示,代码来自<a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> THREAD_POOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_POOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">size_t</span>); <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">auto</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span><br><span class="hljs-function">        -&gt; std::future&lt;<span class="hljs-keyword">typename</span> std::result_of&lt;<span class="hljs-title">F</span><span class="hljs-params">(Args...)</span>&gt;::type&gt;</span>;<br>    ~<span class="hljs-built_in">ThreadPool</span>();<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt; std::thread &gt; workers; <span class="hljs-comment">//工作线程</span><br>    std::queue&lt; std::function&lt;<span class="hljs-type">void</span>()&gt; &gt; tasks; <span class="hljs-comment">//任务队列</span><br>    std::mutex queue_mutex; <span class="hljs-comment">//锁</span><br>    std::condition_variable condition;<span class="hljs-comment">//条件变量</span><br>    <span class="hljs-type">bool</span> stop;<br>&#125;;<br><span class="hljs-comment">// the constructor just launches some amount of workers</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ThreadPool::ThreadPool</span><span class="hljs-params">(<span class="hljs-type">size_t</span> threads)</span></span><br><span class="hljs-function">    :   stop(false)</span><br><span class="hljs-function">&#123;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i&lt;threads;++i) <span class="hljs-comment">//构造函数设置每个线程的任务</span><br>        workers.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]&#123;<br>                <span class="hljs-keyword">for</span>(;;)&#123;<br>                    std::function&lt;<span class="hljs-built_in">void</span>()&gt; task;<br>                    &#123;<br>                        <span class="hljs-comment">//组阻塞直到任务队列不为空(任务队列是个std::function的列表)</span><br>                        std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(<span class="hljs-keyword">this</span>-&gt;queue_mutex); <br>                        <span class="hljs-keyword">this</span>-&gt;condition.<span class="hljs-built_in">wait</span>(lock,<br>                            [<span class="hljs-keyword">this</span>]&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;stop || !<span class="hljs-keyword">this</span>-&gt;tasks.<span class="hljs-built_in">empty</span>(); &#125;);<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;stop &amp;&amp; <span class="hljs-keyword">this</span>-&gt;tasks.<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span>; <span class="hljs-comment">//如果线程池结束了而且当前没任务了就返回</span><br>                        task = std::<span class="hljs-built_in">move</span>(<span class="hljs-keyword">this</span>-&gt;tasks.<span class="hljs-built_in">front</span>());<br>                        <span class="hljs-keyword">this</span>-&gt;tasks.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//从队列中弹出问题</span><br>                    &#125;<br>                    <span class="hljs-built_in">task</span>();<span class="hljs-comment">//执行任务</span><br>                &#125;<br>            &#125;<br>        );<br>&#125;<br><br><span class="hljs-comment">// add new work item to the pool</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ThreadPool::enqueue</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span><br><span class="hljs-function">    -&gt; std::future&lt;<span class="hljs-keyword">typename</span> std::result_of&lt;<span class="hljs-title">F</span><span class="hljs-params">(Args...)</span>&gt;::type&gt;</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> return_type = <span class="hljs-keyword">typename</span> std::result_of&lt;<span class="hljs-built_in">F</span>(Args...)&gt;::type;<br>    <span class="hljs-keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="hljs-built_in">return_type</span>()&gt; &gt;(<br>            std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)<br>        );<br>      <span class="hljs-comment">//future这部分先不管，在下一节</span><br>    std::future&lt;return_type&gt; res = task-&gt;<span class="hljs-built_in">get_future</span>();<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queue_mutex)</span></span>;<br>        <span class="hljs-comment">// don&#x27;t allow enqueueing after stopping the pool</span><br>        <span class="hljs-keyword">if</span>(stop)<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;enqueue on stopped ThreadPool&quot;</span>);<br>        tasks.<span class="hljs-built_in">emplace</span>([task]()&#123; (*task)(); &#125;); <span class="hljs-comment">//加入任务</span><br>    &#125;<br>    condition.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">//加入任务后任务队列肯定不为空了，通知阻塞的工作线程</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// the destructor joins all threads</span><br><span class="hljs-keyword">inline</span> ThreadPool::~<span class="hljs-built_in">ThreadPool</span>()<br>&#123;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queue_mutex)</span></span>;<br>        stop = <span class="hljs-literal">true</span>;<br>    &#125;<br>    condition.<span class="hljs-built_in">notify_all</span>();<br>    <span class="hljs-keyword">for</span>(std::thread &amp;worker: workers)<br>        worker.<span class="hljs-built_in">join</span>();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这个代码还是比较简单的，完美体现了条件变量的使用。</p><h3 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>互斥量<code>mutex</code>和条件变量<code>condition_variable</code>一同构成了并发编程最基本的模型，前者提供互斥机制，保证变量的安全读写，后者提供同步机制，保证了不同任务之前的依赖关系，这两者的实现都基于CPU&#x2F;操作系统提供的相关原语。</p><p>你可能注意到了，互斥量的<code>unlock</code>和条件变量的<code>notify_all</code>都具有通知和唤醒其他线程的能力，但是这个唤醒也仅限唤醒而已。这时候我们就想，能不能提供一个更加抽象的&lt;通知&gt;机制来实现这个唤醒，也就是实际的线程同步操作呢，然后顺便再给它加点功能，比如<strong>唤醒的时候返回一个值</strong>。</p><p>为了达到这一目的，人们进行了进一步的抽象，也就是这篇文章的主题：<code>Future/Promise</code>机制，据说这一机制是来源于函数式编程领域。</p><p><code>Future/Promise</code>的最大特点就是把结果进行了抽象，<code>Future</code>和<code>Promise</code>总是成对出现的：用<code>Future</code>来代表一个任务的结果，用<code>Promise</code>来更新任务的执行状态，借用stack overflow上的一个回答来说就是：<code>promise</code>被生产者使用，<code>Future</code>被消费者使用。</p><ol><li>生产者在完成生产（即任务完成的时候)调用<code>promise.set_value()</code>并将任务已完成这一状态来同步到<code>Future</code>内。</li><li>消费者可以随时通过<code>Future</code>来查询任务的完成状态，也能直接通过<code>Future</code>阻塞当前线程，直到任务完成</li></ol><p>说了这么多还是比较抽象，这里使用一些实际的例子来解释C++内的<code>std::promise</code>和<code>std::future</code>的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; promise;<br>    <span class="hljs-keyword">auto</span> f = promise.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::this_thread::sleep_for(std::chrono::seconds(<span class="hljs-number">5</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        promise.set_value(<span class="hljs-number">12</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task return value is &quot;</span> &lt;&lt; f.<span class="hljs-built_in">get</span>();<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们创建一个promise实例，然后获取到和它对应的Future,紧接着我们创建一个新线程，线程内在5s后才调用<code>promise.set_value()</code>,这里的意思就是模拟t线程内的任务要执行5s，然后得到结果之后通过<code>promise</code>将12这个结果发送给future. t线程在执行完成之前<code>f.get()</code>会一直阻塞直到<code>promise.set_value()</code>执行完成，因此这里运行结果就是主线程会睡眠5s直到t线程运行完成，然后主线程打印12，最后整个程序返回。</p><h4 id="实现简单的future和promise"><a href="#实现简单的future和promise" class="headerlink" title="实现简单的future和promise"></a>实现简单的future和promise</h4><p>说了这么多，这就用<code>mutex</code>和<code>condition_variable</code>来实现一个简单的<code>promise</code>和<code>future</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedStatus</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123; <span class="hljs-comment">//任务状态</span><br>        Pending,<br>        Ready,<br>    &#125;;<br>    Status status = Pending;<br>    std::mutex m;<br>    std::condition_variable cv;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;m)</span></span>;<br>        cv.<span class="hljs-built_in">wait</span>(lk, [&amp;]() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;status == Ready; &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify_all</span><span class="hljs-params">()</span> </span>&#123;<br>        cv.<span class="hljs-built_in">notify_all</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyFuture</span> &#123;<br>    SharedStatus *status&#123;&#125;; <span class="hljs-comment">//和promise共享的状态信息</span><br>    T *value;<br>    <br>    <span class="hljs-function">T <span class="hljs-title">get_value</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//获取值，阻塞直到条件变量通知</span><br>        <span class="hljs-keyword">this</span>-&gt;status-&gt;<span class="hljs-built_in">wait</span>();<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;value; <span class="hljs-comment">//返回</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;status-&gt;<span class="hljs-built_in">wait</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">MyFuture</span>(T *value, SharedStatus *status) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;value = value;<br>        <span class="hljs-keyword">this</span>-&gt;status = status;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>    SharedStatus status; <span class="hljs-comment">//存储所有的条件标量和状态信息</span><br>    T value&#123;&#125;;<br>    <span class="hljs-function">MyFuture&lt;T&gt; <span class="hljs-title">get_future</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//Promise返回的future和当前promise共享所有的状态信息，才能被称之为一对，这里使用一个指针将值也共享了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyFuture</span>&lt;T&gt;(&amp;<span class="hljs-keyword">this</span>-&gt;value, &amp;<span class="hljs-keyword">this</span>-&gt;status);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_value</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;v)</span> </span>&#123;<span class="hljs-comment">//promise在set_value的时候调用notify_all函数通知feture</span><br>        <span class="hljs-keyword">this</span>-&gt;value = v;<br>        <span class="hljs-keyword">this</span>-&gt;status.status = SharedStatus::Ready;<br>        <span class="hljs-keyword">this</span>-&gt;status.<span class="hljs-built_in">notify_all</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>注释写的很清楚了，这里就不再细说，使用我们自己写的<code>MyFuture</code>和<code>MyFuture</code>也能实现上述示例代码类似的效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyPromise&lt;<span class="hljs-type">int</span>&gt; promise;<br>   <span class="hljs-keyword">auto</span> f = promise.<span class="hljs-built_in">get_future</span>();<br>   <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">       std::this_thread::sleep_for(std::chrono::seconds(<span class="hljs-number">5</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">       promise.set_value(<span class="hljs-number">12</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">   &#125;)</span></span>;<br><br>   std::cout &lt;&lt; <span class="hljs-string">&quot;value is &quot;</span> &lt;&lt; f.<span class="hljs-built_in">get_value</span>();<br>   t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><p>运行结果和上述示例一模一样。</p><h4 id="promise-x2F-future机制与异步编程"><a href="#promise-x2F-future机制与异步编程" class="headerlink" title="promise&#x2F;future机制与异步编程"></a>promise&#x2F;future机制与异步编程</h4><p>不知道你有没有发现，<code>Future/Promsire</code>似乎并没有与所谓的多线程绑定，而且示例代码似乎在线程下也能运行(就是没屁用)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; promise;<br>    <span class="hljs-keyword">auto</span> f = promise.<span class="hljs-built_in">get_future</span>();<br>    promise.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">12</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task return value is &quot;</span> &lt;&lt; f.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里会直接打印，因为两个运行在一个线程中，因此不会阻塞。如果我们再封装一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">std::future&lt;T&gt; <span class="hljs-title">run_task</span><span class="hljs-params">(<span class="hljs-type">const</span> std::function&lt;T()&gt; &amp;task)</span> </span>&#123;<br>    std::promise&lt;T&gt; p;<br>    p.<span class="hljs-built_in">set_value</span>(<span class="hljs-built_in">task</span>());<br>    <span class="hljs-keyword">return</span> p.<span class="hljs-built_in">get_future</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">run_task</span>&lt;<span class="hljs-type">int</span>&gt;([]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task return value is &quot;</span> &lt;&lt; f.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样的话，就类似于用一个函数执行一个任务，并且我们并不知道这个任务会啥时候结束，但是我们得到了一个类似<strong>句柄</strong>的东西(也就是返回值future)能够随时查询任务的执行状态，因为这个任务执行完成的时候可以通过内部的promise来更新外部的future的状态。这就是所谓的<strong>异步编程</strong>,我们这里没有体现异步是因为<code>run_task</code>是和主线程一起跑的，和直接调用函数没啥区别，但是别忘了，我们可以在<code>run_task</code>内部加上一个新线程，甚至一个线程池，这样就变成真正的异步编程了，当然这东西也不需要我们自己实现，因为c++内部已经提供了一个：<code>std::async_task</code>,下面是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> task = []() &#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">4</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> f = std::<span class="hljs-built_in">async</span>(task);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;task won&#x27;t block current thread\n&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;task return value is &quot;</span> &lt;&lt; f.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相信看到这里这行代码啥意思也不需要我来讲了。</p><p>到这里还不够，你可能会好奇<code>std::async</code>内部是怎么创建新线程，以及如果我们同时添加多个异步任务，<code>std::async</code>内部会如何调度呢，为了解决这个问题，人们又从异步编程中抽象出来一个东西：<code>executor</code>,也就是专门用来执行任务的，可配置的执行器，由于这个东西还没在C++中完全对外暴露接口，这里我也就不细说了。当然到了这里我们也需要注意到,<code>executor</code>已经超出了线程池的概念了，它就是是一个任务调度器，完全可以在单线程中执行。</p><h3 id="Async和Await"><a href="#Async和Await" class="headerlink" title="Async和Await"></a>Async和Await</h3><p>说到这里就可以慢慢引出来<code>async</code>和<code>await</code>了，这两个东西已经和C++没啥关系，就一个单纯的异步任务执行抽象: 使用<code>async</code>来定义一个异步任务，使用<code>await</code>来等待一个异步任务的结束。在此基础上配合一个外部的<code>executor</code>来进行任务执行和调度。这两个东西已经作为<code>python</code>,<code>rust</code>等编程语音的关键字，成为受编译器支持的异步编程模型的基础设施。由于这里不是<code>async</code>和<code>await</code>的专场，因此这里不细说了，有空再开一篇文章专门说下这两个东西内部原理(其实是我自己还没搞清楚)。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何让clangd在vscodium下支持使用MSVC编译器的Cmake工程</title>
    <link href="/posts/3172/"/>
    <url>/posts/3172/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于下面的一些原因：</p><ol><li>不想使用微软开发的C++插件(一是Vscodium内不提供，二是这东西确实不太好用，3.5分)</li><li>项目使用Cmake + MSVC构建(Gcc或者说Mingw的ABI和项目不兼容)</li></ol><p>我就产生了标题的想法，也就是说如何让clangd在vscodium下支持使用MSVC编译器的Cmake工程,或者表述为一个比较常见的场景：如何抛弃微软的C++插件在vscode&#x2F;vscodium上使用MSVC开发C++。</p><p>为了达到这一目的，我很快就找到了LLVM官方提供的C++ LSP: clangd。但是在windows下使用这个插件还是需要折腾下的的，一方面是好多人不会翻阅文档，另一方面是Cmake在某些方面比较拐弯抹角。</p><p>下面我从一个新安装的Vscodium(完全开源并重新打包的vscode)开始一步步描述怎么在windows下正常使用<code>clangd</code>.</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>这里已经默认你已经安装好了CMake和MSVC.</p><h3 id="安装-llvm"><a href="#安装-llvm" class="headerlink" title="安装 llvm"></a>安装 llvm</h3><p>clangd的本体是llbm工程的一部分，使用这个东西自然要安装llvm，不要嫌弃llvm太大，虽然它的大部分功能我们大概用不到，但是里面的好多小工具还是挺好的，比如clang-tidy, clanng-format等等。</p><p>前往llvm的github主页下载安装器，双击安装，然后添加环境变量，这一步应该不用我多说，和普通的开发相关软件的安装方法一样，在这一步完成后打开终端输入相关命令检查安装是否正常：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> C:\Users\xhy\blog&gt; clang<span class="hljs-literal">-format</span> <span class="hljs-literal">--version</span><br>clang<span class="hljs-literal">-format</span> version <span class="hljs-number">14.0</span>.<span class="hljs-number">0</span><br><span class="hljs-built_in">PS</span> C:\Users\xhy\blog&gt; clang <span class="hljs-literal">--version</span><br>clang version <span class="hljs-number">14.0</span>.<span class="hljs-number">0</span><br>Target: x86_64<span class="hljs-literal">-pc-windows-msvc</span><br>Thread model: posix<br>InstalledDir: C:\Program Files\LLVM\bin<br><span class="hljs-built_in">PS</span> C:\Users\xhy\blog&gt; clangd <span class="hljs-literal">--version</span><br>clangd version <span class="hljs-number">14.0</span>.<span class="hljs-number">0</span><br>Features: windows<br>Platform: x86_64<span class="hljs-literal">-pc-windows-msvc</span><br><span class="hljs-built_in">PS</span> C:\Users\xhy\blog&gt;<br></code></pre></td></tr></table></figure><h3 id="安装-ninja"><a href="#安装-ninja" class="headerlink" title="安装 ninja"></a>安装 ninja</h3><p><code>clangd</code>对于Cmake的支持需要借助一个名叫<code>compile_commands.json</code>的文件来进行，这个文件记录了编译整个工程需要执行的所有编译命令等信息。如果直接使用<code>Cmake .. -G &quot;Visual Studo 17 2022&quot;</code>，Cmake则不会生成<code>compile_commands.json</code>。这是因为官方文档上写着Camke仅支持在<code>Ninja</code>和<code>GUN Makefiles</code>规则下支持<code>compile_commands.json</code>，至于为什么会这样我也不清楚，因此为了生成这个文件，我们只能借助<code>ninja</code>这个小构建工具。</p><p>安装的步骤也不用多讲,这东西就一个可执行文件,将其放到任意目录,然后添加环境变量即可,输入<code>ninja --version</code>:</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">PS <span class="hljs-name">C</span>:\Users\xhy\Desktop\ninja&gt; ninja <span class="hljs-comment">--version</span><br><span class="hljs-number">1.10</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><h3 id="安装相关插件"><a href="#安装相关插件" class="headerlink" title="安装相关插件"></a>安装相关插件</h3><p>请注意，这里我们仅需要安装如下两个插件:</p><ol><li>clangd 提供clangd对vscode的支持</li><li>Cmake 提供Cmake的基本高亮</li><li>Cmake Tools(可选,这东西每次打开工程会自动执行cmake命令,我个人不喜欢)</li></ol><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>到这里我们就能新建工程了，下面给出基本的文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>**)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的第三行<code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)</code>一定要写,这是clangd能正常补全的关键所在.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><span class="hljs-keyword">project</span>(demo VERSION <span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>)<br><span class="hljs-keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">add_executable</span>(demo main.cpp)<br></code></pre></td></tr></table></figure><p>好了,到目前为止我们就得到如下的工程:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── CMakeLists<span class="hljs-selector-class">.txt</span><br>└── <span class="hljs-selector-tag">main</span>.cpp<br></code></pre></td></tr></table></figure><p>这时候如果你装了<code>cmake tools</code>就不要用vscodium打开当前工程,因为它会自动根据默认规则执行cmake并生成相关cmake缓存,而不是用我们指定的规则.如果你已经打开了就请删除自动生成的Build目录.</p><h3 id="执行Cmake"><a href="#执行Cmake" class="headerlink" title="执行Cmake"></a>执行Cmake</h3><p>这一步要单独拿出来说是因为有一些小细节需要注意.我们在windows下使用<code>Cmake .. -G Ninja</code>规则执行cmake时cmake会自动使用mingw编译器,而不是msvc,这里应该可以用命令强制使用msvc,但是我不会整,因此我的做法是打开<code>Developer Command Prompt for VS 2022</code>从这里进入我们项目的主目录,这时候因这个终端有环境变量,我们再新建build目录,然后执行<code>Cmake .. -G Ninja</code>,就能生成以msvc为后端的ninja + cmake工程了.</p><h3 id="打开编辑器"><a href="#打开编辑器" class="headerlink" title="打开编辑器"></a>打开编辑器</h3><p>到这一步,我们终于能打开编辑器了,你会发现clabgd能正常补全MSVC编译器下的cmake项目了.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>P=NP?--算法复杂性和NP问题概述</title>
    <link href="/posts/c8e9/"/>
    <url>/posts/c8e9/</url>
    
    <content type="html"><![CDATA[<h2 id="PUF（物理不可克隆功能）"><a href="#PUF（物理不可克隆功能）" class="headerlink" title="PUF（物理不可克隆功能）"></a>PUF（物理不可克隆功能）</h2><h3 id="理论定义"><a href="#理论定义" class="headerlink" title="理论定义"></a>理论定义</h3><p>PUF指的是在物理上对于<strong>任意激励</strong>产生的一个<strong>唯一</strong>且不可预测的输出响应，通常基于半导体制造过程中自然发生的独特物理变化。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">任意激励</span><span class="hljs-literal">--</span>&gt;<span class="hljs-title">[</span>  <span class="hljs-comment">PUF发生器</span>  <span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">唯一且不可预测的特征响应</span><br></code></pre></td></tr></table></figure><h3 id="SRAM-PUF"><a href="#SRAM-PUF" class="headerlink" title="SRAM PUF"></a>SRAM PUF</h3><p>目前的PUF一般都是基于SRAM的PUF实现(具体原理由于不是重点因此不细讲),可直接集成到IOT设备&#x2F;芯片中。</p><p>特点：</p><ul><li>无需编程&#x2F;无需从外部获取熵(随机性)</li><li>即时生成，设备断电后不会存储任何PUF指纹信息</li><li>通用性强(芯片都有SRAM)</li></ul><p>IOT设备的<strong>SRAM PUF响应在设备制造出来时，就已确定</strong>。</p><p>这里要注意一点，虽然<strong>PUF响应唯一，但是响应的实际比特序列会受到温度，电压等环境的影响</strong>，因此响应不能直接用作密钥或者认证标识，将其转换成高质量的安全密钥需要进一步处理,如<strong>滤波，纠错</strong>等方法。</p><h2 id="认证技术"><a href="#认证技术" class="headerlink" title="认证技术"></a>认证技术</h2><p>一种权限验证的大致框架(由论文简化而来<a href="https://ieeexplore.ieee.org/document/9233424)%EF%BC%9A">https://ieeexplore.ieee.org/document/9233424)：</a></p><p><img src="https://tvax1.sinaimg.cn/large/007bwgzIgy1h54g71ucyqj30qv09bwgd.jpg" alt="image"></p><p>在描述整个过程之前需要明确：</p><ol><li><p>PUF的唯一响应在使用前<strong>需要使用特定的算法进行纠错和滤波,经过该操作后才称为硬件指纹</strong></p></li><li><p><strong>边缘节点已经记录了自己所连接的所有IOT设备的硬件指纹(纠错后的PUF响应，由IOT设备的制造商提供)</strong></p></li><li><p>边缘节点生Challenge(具体生成看不同的算法，但是为了安全性需要带有随机性)</p></li><li><p>边缘节点将Challenge加密后发送给IOT设备</p></li><li><p>IOT设备根据解密后的Challenge和自身的硬件指纹，使用一组特定的算法(即身份验证HASH生成器)生成特定的哈希(这个哈希在后面被用作鉴权)</p></li><li><p>IOT设备将加密后哈希(可能包含其他信息)发送给边缘节点</p></li><li><p>边缘节点对收到的加密哈希进行解密操作复原出IOT设备的HASH1</p></li><li><p>边缘节点从自身存储的IOT硬件指纹表中查询该IOT的硬件指纹，使用和IOT端相同的输入算法(即在本地算一遍第三步)计算出一个HASH2</p></li><li><p>将本地计算出来的HASH2和IOT设备发送的HASH1进行比对，以判定该IOT是否合法</p></li></ol><p>优势：</p><ol><li>不会泄露PUF指纹</li><li>能够进行IOT设备的有效认证</li></ol><h3 id="其他的身份认证技术"><a href="#其他的身份认证技术" class="headerlink" title="其他的身份认证技术"></a>其他的身份认证技术</h3><ul><li>阿里云和腾讯云的IOT身份认证：由云提供方提供设备ID,设备密钥对等身份信息，并<strong>烧录</strong>到IOT设备中。权限验证由云自身的认证中心提供，其流程与PUF类似，区别在于IOT设备内会存储相关的身份信息.</li><li>…</li></ul>]]></content>
    
    
    <categories>
      
      <category>IOT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LFS--日志文件系统介绍</title>
    <link href="/posts/6c99/"/>
    <url>/posts/6c99/</url>
    
    <content type="html"><![CDATA[<h2 id="Flash的结构简介"><a href="#Flash的结构简介" class="headerlink" title="Flash的结构简介"></a>Flash的结构简介</h2><p>由于本文章的主体为对LFS的介绍,介绍Flash也是为了引出LFS,因此这里对Flash的介绍也是点到为止,而不会太过深入.回到正题,开始正式介绍Flash.</p><p>Flash是一种新兴的存储介质,一个完整的NAND闪存芯片布局如下图(来自<a href="https://flashdba.com/">https://flashdba.com/</a>)所示,一个芯片(或者说一个封装)中有多个Plane,而每个Plane中有多个Block,每个Block内又有多个Page,至于Page内就是我们常说的MLC,SLC等颗粒，这些是什么以及怎么通过硬件实现和控制的则不是我们的关注重点.下面描述一下Flash的读写特性.</p><p><img src="https://flashdba.files.wordpress.com/2014/06/nand-flash-die-layout.png"></p><p>Flash支持三种最基本的操作：</p><ol><li>读，基本粒度是Page,也就是说你每次读的基本单位是Page</li><li>写,基本单位也是Page,不过有一点要注意的是，<strong>写之前要对Page进行擦除</strong></li><li>擦除，擦除的操作就是清空内容，但是<strong>擦除的基本单位是Block</strong>,也就是说Flash无法做到Page粒度的擦除操作</li></ol><p>在描述完上述的基本操作之后，相想必你也意识到了Flash的问题所在：无法精确地更新(包括变更部分内容或者擦除)一个Page，要做到这一点，你需要如下的步骤：</p><ol><li>找到一个空的Block</li><li>将目标的整个block赋复制到一个这个空Block中</li><li>擦除整个目标Block</li><li>将你要更新的page的内容写入该block中的对应位置</li><li>将不需要更新的page内容拷贝回原来的地方</li><li>擦除最开始的空的Block</li></ol><p>显而易见，这样做是极不划算的，因为会使Flash的寿命大打折扣，因为每次更新都需要多次擦除不止一个Block.</p><p>为了解决这一问题，我们可以使用一种简单的标记法假擦除的方法：</p><ol><li>找到一个空Block</li><li>将要更新的Page以及不需要更新的Page写入这个空的block</li><li>将原来的Block标记为无效</li></ol><p>这样做就一次擦除都不需要了，但是也带来了新的问题：首先从传统文件系统的角度来看，最严重的问题是数据块的物理地址(PBA)改了，那我下次读文件不是就读到错误的内容了吗？问题2就是这样做空余的block就会越来越少，但是无效的Block就会越来越多。</p><p>面对一个复杂的计算机问题，抽象就是最好的解决办法，现在的Flash都在“逻辑数据块”和“物理数据块”之间添加了一个转换层：每次读写文件都要先经过这个转换层，转换层会根据输入的逻辑地址查找对应的物理地址，然后使用这个物理地址去对应的page中读取。这样一来就解决了问题1，因为我们改变block位置后更新这个转换层的映射表即可。这个所谓的转换层就是闪存转换层(flash translation layer,FTL)。为了解决问题2，这里需要引入一个<strong>垃圾回收</strong>过程，说简单点就是在后台定期地将无效的Block擦除，并标记为空闲的Block。实际上FTL承担的任务还有擦除均衡等内容，这里就不细说了。</p><h2 id="Log-structured-File-System"><a href="#Log-structured-File-System" class="headerlink" title="Log-structured File System"></a>Log-structured File System</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>上面对FTL的介绍实际上就引出了LFS——日志结构的文件系统。至于为什么这么说，看完后面对LFS的介绍就明白了。</p><p>LFS一开始并不是为了Flash设备而设计的，因为它被提出的时候Flash还没那么流行。和传统的文件系统（如Ext4）最不同的事情是，<strong>LFS将随机读写转换成了顺序读写</strong>。这也是它叫”日志结构”文件系统的原因。LFS将整个存储介质看成一个append only的log文件,每次写入都是顺序写，内容总是追加在日志的最后,下图展示了LFS的基本原理：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">Flash:  [ File1 | <span class="hljs-type">File2</span> | <span class="hljs-type">File1</span>&#x27;s update1| <span class="hljs-type">File2</span>&#x27;s update1 ]<br></code></pre></td></tr></table></figure><p>下面举一个简单的粒子，文件S一开始有ABC三个块（文件系统读写的最小单位）：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">[A|<span class="hljs-string">B</span>|<span class="hljs-string">C</span>|<span class="hljs-string">... ]</span><br></code></pre></td></tr></table></figure><p>如果在这时候我更新文件S的A,C块，那么这时候块序列就会变成如下这样(暂时忽略元数据的组织):</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">[(A)|<span class="hljs-string">B</span>|<span class="hljs-string">(C)</span>|<span class="hljs-string">A</span>|<span class="hljs-string">C</span>|<span class="hljs-string">...]</span><br></code></pre></td></tr></table></figure><p>这里加括号的意思就<strong>旧的文件块会被标记为无效，而不是直接覆盖</strong>，如果覆盖的话就变成随机写了。</p><p>在这种结构下LFS有着极高的写入速度，但是显然也存在着很大的问题:<strong>随着文件的更新，文件系统内部会产生大量的无效数据块，快速占满整个文件系统</strong>。</p><p>面对这个问题，相信你也猜到了，就是进行<strong>垃圾回收</strong>：所谓的垃圾回收，就是<strong>在文件系统空闲或者文件系统没有空余空间的时候，对整个文件系统进行重排，删除无效的数据块以腾出空间的过程。</strong></p><h3 id="LFS结构简单介绍"><a href="#LFS结构简单介绍" class="headerlink" title="LFS结构简单介绍"></a>LFS结构简单介绍</h3><p>在明白原理后，这里对LFS的元数据组织做下简单的介绍，因为后面还要介绍一个现在很流行的LFS实现，因此这里就简单说下。LFS将整个文件系统分为多个段(Segment),每个segment内部有多个Block，Block自身又分为三种：包含文件实际内容的块，存储inode信息的文件元数据块，组织段内Inode信息的inode map块。</p><p><img src="https://pic1.zhimg.com/80/v2-e2d18cf2debe20993e1cebc73ac43bd0_720w.jpg"></p><p>(图来自<a href="https://zhuanlan.zhihu.com/p/41358013">https://zhuanlan.zhihu.com/p/41358013</a>)</p><p>每次向Sgement内写入多个数据块后LFS就会在后面追加一个inode块以对新追加的数据块进行索引,请注意Inode的位置并不固定，因此为了定位Inode的位置，LFS在每个segment尾部追加了一个索引inode的块，称之为Inode map。而每个inode map的位置则缓存在内存中。这样就形成了一个多级索引结构，用于对文件的读写。</p><p>在LFS中读取一个inode号为i的文件的流程如下所示：</p><ol><li>从内存中缓存的inode map中读取所有段中inode为i的地址，也就和i相关的所有inode</li><li>从每个inode中读取每个相关的data block的位置</li><li>读取data block的位置</li></ol><p>这样的设计其实也挺麻烦的，要一级一级地往下读，因此这种设计并没有被广泛采用，直到LFS提出20年后，闪存技术高速发展，F2FS被提出，LFS才被慢慢广泛使用。</p><h2 id="F2FS"><a href="#F2FS" class="headerlink" title="F2FS"></a>F2FS</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>F2FS是历史上第一个真正被广泛使用的日志文件系统。</p><p>如下图所示：F2FS的主体分为metadata和data两个区域，前者主要存储元数据，采用普通的随机读写方式。后者是存储文件数据以及inode的数据区域，是典型的追加写的模式（或者说叫序列写）。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/d4hoYJlxOjMvlpLZq7rbttib4LozyaRwcFX0taTCicIw40VsyNlbOomcxQ3xSxE0R5uj2vYyGoH2YcgHgYKOniafg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"></p><h3 id="元数据区域"><a href="#元数据区域" class="headerlink" title="元数据区域"></a>元数据区域</h3><p>元数据区域分为如下几个部分：</p><ol><li>超级块（Super Block）包含一些基本的分区信息以及其他一些不变的信息，不是我们关注的重点</li><li>段信息表(Segemnt Info Tale,SIT) 包含数据区域内每个段的有效块的数量以及标记每个块是否有效的位图，该部分的元数据主要用于垃圾回收过程中需要搬移的段以及识别段中的有效数据</li><li>索引节点表(Node Address Table, NAT) 用于定位数据区域中的索引节点块，包括每个inode节点的地址等信息。</li><li>段摘要区域(Segment Summary Table,SST)数据区域中所有数据块的父节点信息，也就是一个反向索引（用于当当前节点的位置发生变化时候更新父节点信息）</li><li>检查点(CP): 保存文件系统的状态，方便崩溃和掉电后的系统崩溃等。</li></ol><h3 id="数据区域"><a href="#数据区域" class="headerlink" title="数据区域"></a>数据区域</h3><p>和F2LS的结构基本相同，F2FS中的数据区域也由多个Segment排列而成。每个Segment中有多个数据块以及多个Inode节点，Inode用于索引数据块，而Inode的地址则被存储在元数据区中的NAT表中。由于NAT表的存在，F2FS中就不存在Inode map这种东西了。</p><h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>下面介绍下F2FS的工作流程。</p><p><strong>写</strong>.和最开始的LFS一样,F2FS也是直接往段的尾部追加文件块和Inode信息,在写完文件块后LSFS会更新NAT表以把新增加Inode纳入NAT的索引中,这时候不要忘记旧Block已经无效了,因此这里还要更新SIT表更新有效性索引信息便于垃圾回收,请注意删除也是写的一种,因此这里不再独立讲删除流程.</p><p><strong>读</strong>.为了读一个文件,F2FS会在NAT表中查询该文件所有的Inode节点的位置,并根据这些位置信息读取所有的Inode节点,最后根据Inode节点读取所有有效的文件Block,最后选最新(即有效)的Block组合到一起即可</p><p><strong>垃圾回收</strong>.当如下两个条件发生一个时,F2FS会以一定的策略进行垃圾回收:</p><ol><li>在追加文件块的时候发现整个文件系统中已经没有空闲段</li><li>文件系统的IO空闲的时候(有后台线程管理这个事情)</li></ol><p>在上述两个条件满足一个的时候,文件系统会读取SIT表,也就是所有段内数据块的有效性信息,找到一些<strong>包含最少有效块</strong>的segment,并使用随机读写的方式删除所有的无效块,然后把所有的有效块挪到段的头部方便后面再次写入.这时候由于有大量的文件块被移动了,为了防止父节点找不到该数据块的情况,因此这里还需要修改SST表已更新父节点的信息.</p><p>F2FS的实际设计远比我这里写的要复杂,总之这篇文章的主要目的还是做个简单的总结.</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMDM0NjExNA==&mid=2247483792&idx=1&sn=3653294db298b1a42263ccb526592f69&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz&#x3D;MzAxMDM0NjExNA&#x3D;&#x3D;&amp;mid&#x3D;2247483792&amp;idx&#x3D;1&amp;sn&#x3D;3653294db298b1a42263ccb526592f69&amp;scene&#x3D;21#wechat_redirect</a></li><li><a href="https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/">https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何维护一个C++开源项目--从编译器到Github</title>
    <link href="/posts/9623/"/>
    <url>/posts/9623/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020年年中的时候，我在Github上开源了一个简单的Minecraft模组(下面以tr代称)，由于受到社区的广好评，我就一直维护，到现在依然在更新。虽然目前只有180个星星，但是这个小项目也见证了我在C++以及开源这方面不小的成长。因此，趁着没事干这一契机，打算把我之前遇到的问题以及经验写下来，供给其他人参考。</p><h2 id="软件开发与维护"><a href="#软件开发与维护" class="headerlink" title="软件开发与维护"></a>软件开发与维护</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>​本科学软件工程的时候我就知道，要想软件扩展性高，就要进行模块化设计，每个模块各司其职，这样才能方面后续扩展和维护。一开始我也确实做到了这点，但是后期就会发现一个问题，那就是<strong>过度设计</strong>。这也是我在这里最想说的东西。</p><p>​Tr是一个游戏mod，但是它没有用任何第三方提供的游戏内API，而是使用一些特殊的工具(如HOOK库)来达成某些特殊的目的。当时的我想的是把侵入游戏的部分(也就是HOOK)独立出来做出一个类似第三方API的库，然后mod本身以这个库作为依赖，从而达到解耦的目的，我甚至还想过以后这个API库能够供给其他人使用，达到减小开发成本的目的。(因此你可以发现tr的源码有<code>api</code>和<code>mod</code>两个主要目录)。</p><p>​我也确实是这么做的，我甚至写了一个<code>DBSMod</code>的抽象类，将其放到<code>api</code>目录，然后在<code>mod</code>内写<code>TrapdoorMod</code>并继承这个类。但是后面出现了以下几个问题：</p><ol><li>我无法很好地区分哪些算是所谓的API，而哪些属于mod的部分，这导致后期开发的时候两个模块内的内容比较混乱，api完全没法独立出来</li><li>我根本没有经历去维护一个所谓的第三方API库，前段时间甚至有个外国的社区开发者在dc上问我tr的api怎么用，这直接给我问懵了，因为目前的设计根本没法支持将将API独立出来给别人用，并且我也没办法对这个API的稳定性和可靠性做任何保证</li><li>强行分成两个部分导致了我后期的部分编码不便，最后我不得不重构部分代码</li></ol><p>我认为上述问题都是过度设计引起的，既然我一开始只想写mod，而不是模组框架，那么就不该做这种模糊的划分，拆分反而会加剧开发难度。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>​<strong>编译器的选择</strong>。正如上面所说，因为这里需要侵入<code>exe</code>文件内部，因此为了保证abi的兼容性，我一开始以为只能使用<code>msvc</code>作为编译器。知道后面我才知道，windows上的<code>clang</code>使用的默认后端就是<code>msvc</code>，因此clang也是可行的选择，但是考虑到各类编辑器&#x2F;IDE对编译器的支持程度，我最后还是选择了<code>msvc</code></p><p>​<strong>构建系统</strong>。因为习惯原因，我选择了<code>Cmake</code>作为这个项目的构建系统，最重要的原因当然是我相对来说更加熟悉，此外，我不喜欢编码被某个ide绑定，因此我没有使用windows上更加常用的vs方案，因此这样就只能使用Visual studio来进行代码编写了。</p><p>​<strong>C++版本</strong>。毫无疑问我选择了C++17，使用更新的标准肯定没坏处(不用20是因为这个变化有亿点大，且各个编译器对其支持都不完全)</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>​由于对C++比较熟悉，因此我在这上面遇到的问题并不算多，下面就列举几个有代表性的:</p><ol><li><p>头文件的相互引用。可以说这是我遇到的最大的问题了，早期的tr由于代码足够简单，所有的代码都在<code>.h</code>中(你还能在早期版本的源码中看到这一个盛况)，这导致编译根本过不了，而且对于一个没有经验的开发者来说很难找到错误，不过最后我及时回头，将所有的实现和声明拆开，以后就再也没遇到这个问题了</p></li><li><p>全局变量问题。从现在的眼光来看，c++因为其面向对象的特点，是能够相对容易地避免全局变量的(这里就要吐槽下C语言了，到处都是<code>extern</code>)，但是当时我并不知道这些，导致早期的tr代码全局变量随处可见。因此为了方便后期维护，我将所有的全局变量写道了一个类里面，然后使用<code>staic</code>对象的方案来获取这对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TrapdoorMod&amp; <span class="hljs-title">mod</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> TrapdoorMod mod;<br><span class="hljs-keyword">return</span> mod;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>​这里的规范化主要是指代码风格和格式化。对于代码风格，我沿用了自己之前写<code>java</code>的那套风格，类名首字母大写，变量名首字母小写等等，也和mojang的代码风格保持相对一致。对于代码格式化问题，我一开始用的CLion进行代码编写，后面因为工程越来越大，加之我电脑性能有限，后面改为用vscode开发，这时候问题就出现了，clion和vscode对C++代码的格式化风格不一样，这样你修改一行代码，保存后文件会全部重新格式化，因此就相当于提交了许多无效信息。</p><p>​CLion的格式化风格只能在自己的配置文件修改，这个配置文件严格来说<strong>不属于项目</strong>的一部分。总不能每次切换ide就重新配置一次。最后的解决方案是使用<code>clang-format</code>,这个工具可以读取给定的配置文件，对指定的代码使用配置文件规定的风格进行格式化。由于这个工具早就被广泛使用，因此CLion和vscode都支持这个工具。项目目前的配置文件如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#.clang-format</span><br><span class="hljs-attr">Language:</span> <span class="hljs-string">Cpp</span><br><span class="hljs-attr">BasedOnStyle:</span> <span class="hljs-string">Google</span><br><span class="hljs-attr">UseTab:</span> <span class="hljs-string">Never</span><br><span class="hljs-attr">IndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-attr">NamespaceIndentation:</span> <span class="hljs-string">All</span><br><span class="hljs-attr">ColumnLimit:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>​当然，使用clang-format也给我带来了一些问题，比如在某些情况下，头文件B必须要在头文件A之前include,项目才能正常编译通过。但是每次<code>clang-format</code>自动格式化的时候，就会默认对自定义头文件根据首字母排序，这样A就到了B前面，导致编译失败。解决这个问题办法是在你不需要格式化的代码上下加两个注释，以提示<code>clang-format</code>，下面是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// clang-format off</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;B.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;A.h&quot;</span></span><br><span class="hljs-comment">// clang-format on</span><br><span class="hljs-comment">//这时候clang-format不会格式化上面两行</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>​<strong>单步调试永远不应该是你的第一选择</strong>。虽然<code>*db(lldb,gdb)</code>等这些调试工具十分好用，但是它们也有自己的局限性：<strong>不能预防错误,或者说在程序出错时无法立即告诉你错误在哪</strong>，而是你发现程序出错后，再使用<code>gdb</code>跑一遍程序，去定位错误位置，然后查错误位置附近的内存数据以查找bug。</p><p>​<strong>使用日志和断言来进行错误语法和检测</strong>。你可以在关键位置打上日志，这样可以随时插查看程序的运行情况，而不是等出错后再使用<code>gdb</code>去查看。使用<code>assert()</code>可以<strong>让程序在其行为与你的预期不一致的时候提醒你</strong>。而且这些输出都可以通过宏来控制，不用在发布的时候再去删除相关代码。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​由于tr自身的特殊性(不是可执行文件，而是一个只能附加到进程的dll)，并且绝大多数内容都是和游戏内数据进行打交道，但是游戏内部对我们来说就是个黑盒，因此无法使用常规的方法如单元测试等来测试程序的正确性。面对这一点我暂时也没很好的解决方案，基本的测试也就这两个方面：</p><ol><li>从开发者角度，写完后在游戏内进行实际的测试</li><li>从用户的角度，等待用户进行bug反馈</li></ol><h3 id="自动打包-x2F-发布"><a href="#自动打包-x2F-发布" class="headerlink" title="自动打包&#x2F;发布"></a>自动打包&#x2F;发布</h3><p>​这部分内容我在此之前没有任何经验，甚至不知道<code>CI/CD</code>是什么。在开发tr的过程中，每当要我要发release的时候，都得做如下的操作：</p><ol><li>修改编译参数为release模式以提高性能并屏蔽所有debug输出</li><li>重新编译整个文件</li><li>复制dll，配置文件，readme以及其他一些调试文件到某个空文件夹‘</li><li>压缩文件夹为压缩包</li><li>上传压缩包到github并写release note</li></ol><p>​这些步骤做一两次还觉得无所谓，但是重复次数太多后就觉得很烦且浪费时间，后来我我写了一个脚本自动化帮我完成<code>3-4</code>两个步骤，但是我还是觉得编译和上传这两个步骤太麻烦。</p><p>​后来我了解到了<code>github action</code>这个东西，它能根据配置文件定义的工作流，在特定的时候自动完成<code>1-5</code>的所有工作。配置文件大概长下面这个样子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Actions</span> <span class="hljs-string">Demo</span><br><span class="hljs-attr">on:</span> [ <span class="hljs-string">push</span> ]<br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">Build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">windows-latest</span><br>    <span class="hljs-attr">steps:</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">checkout</span> <span class="hljs-string">code</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Pull</span> <span class="hljs-string">submodule</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">FetchSDK.cmd</span><br>        <span class="hljs-attr">shell:</span> <span class="hljs-string">cmd</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Download</span> <span class="hljs-string">Server</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir D:/BDS</span><br><span class="hljs-string">          ServerLink=$(cat &#x27;LINK.txt&#x27;)</span><br><span class="hljs-string">          curl -L -o D:/BDS/server.zip &quot;$ServerLink&quot;</span><br><span class="hljs-string">          unzip D:/BDS/server.zip -d D:/BDS &gt; /dev/null</span><br><span class="hljs-string"></span>        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">Bedrock</span> <span class="hljs-string">Library</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          cd SDK/Tools</span><br><span class="hljs-string">          LibraryBuilder.exe -o ..\Lib D:\BDS</span><br><span class="hljs-string"></span>        <span class="hljs-attr">shell:</span> <span class="hljs-string">cmd</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">CMake</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">cmake</span> <span class="hljs-string">-B</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/build</span> <span class="hljs-string">-DBETA=PFF</span> <span class="hljs-string">-DDEV=OFF</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">cmake</span> <span class="hljs-string">--build</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">Artifact</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir out</span><br><span class="hljs-string">          mkdir out/plugins</span><br><span class="hljs-string">          mkdir out/plugins/trapdoor</span><br><span class="hljs-string">          cp ./build/Debug/trapdoor*.dll ./out/plugins/</span><br><span class="hljs-string">          cp ./src/base/config.json ./out/plugins/trapdoor/</span><br><span class="hljs-string">          cp ./changelog.md ./out/</span><br><span class="hljs-string">          cp ./README.md ./out</span><br><span class="hljs-string"></span>        <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">Actions</span> <span class="hljs-string">File</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/upload-artifact@v1.0.0</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">release</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/out</span><br><br>      <span class="hljs-comment">#create release</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Prepare</span> <span class="hljs-string">Release</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          7z a release.zip $&#123;&#123;github.workspace&#125;&#125;/out</span><br><span class="hljs-string">          python create_release_note.py</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Publish</span> <span class="hljs-string">Release</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">softprops/action-gh-release@v1</span><br>        <span class="hljs-attr">if:</span> <span class="hljs-string">startsWith(github.ref,</span> <span class="hljs-string">&#x27;refs/tags/&#x27;</span><span class="hljs-string">)</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">body_path:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.workspace</span> <span class="hljs-string">&#125;&#125;/release_note</span><br>          <span class="hljs-attr">files:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            release.zip</span><br><span class="hljs-string"></span>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">GITHUB_REPOSITORY:</span> <span class="hljs-string">hhhxiao/trapdoor-ll</span><br></code></pre></td></tr></table></figure><p>​这个文件定义了从编译到发布release的所有流程，并且可以在github自己提供的免费服务器上运行，不需要我本地操心。但是这个东西唯一的缺点就是编写过程中调试麻烦，由于github提供的机器性能有限，每次编译要等个五六分钟，如果发现后面的脚本有一个地方写错了，这个workflow又要从零开始跑一遍，我当时这个脚本写了20来个版本才把所有流程完全搞定。不过它带来的回报就是现在tr的release完全由这个action自动完成，再也不用我自己走那一套流程了。</p><h2 id="社区支持"><a href="#社区支持" class="headerlink" title="社区支持"></a>社区支持</h2><p>一个开源软件的发展离不开社区的支持。因此在写代码之外维护仓库也是必要的一环。</p><h3 id="文档支持"><a href="#文档支持" class="headerlink" title="文档支持"></a>文档支持</h3><p>​文档支持分README和详细文档两部分。前者就在github主页，需要用简练的语言介绍项目是做什么的，有什么用，以及如何使用。如果你有心情的话甚至可以画一个logo。后者就是对你开发的工具&#x2F;库的详细介绍，包括详细的安装流程和使用方法，甚至可以附带编译方法，如何二次开发等内容。为了写tr的文档我甚至去学了一波Vuepres。</p><h3 id="社区交流"><a href="#社区交流" class="headerlink" title="社区交流"></a>社区交流</h3><p>​这部分我也觉得可以分为两部分，一部分面对普通用户，一部分面对开发者。对于普通用户，交流的主要平台就是<code>Issue</code>页面，作为主要维护者，我们应该熟悉issue的label和close功能，label就是给问题打一个tag，表示开发者对这个issue的定性，是bug，还是没事找事等等，而close就是处理完的问题要及时关闭，以免占据issue的版面。</p><p>​对于开发者，作为一个开源项目，应该都是乐于看到其他开发者对自己项目的pr以及基于该项目的二次开发的。为了方便开发者进行二次开发，我们也应该在文档上写上如何编译，以及简单介绍项目的技术栈和架构等等。此外，也会有部分“蹭提交”的开发者，因为你不管pr了什么，pr了多少内容，都会显示在项目主页上。因此作为维护者我们不应该顾及所谓的“人情”或者为了让项目看起来更加活跃而忽视代码检查，防止一粒老鼠屎坏了一锅粥。特意强调这个就是因为我自己吃了这个的亏，具体的就不细说，反正就当买教训了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>史诗级退化——全新的博客系统</title>
    <link href="/posts/2334/"/>
    <url>/posts/2334/</url>
    
    <content type="html"><![CDATA[<h1 id="史诗级退化——全新的博客系统"><a href="#史诗级退化——全新的博客系统" class="headerlink" title="史诗级退化——全新的博客系统"></a>史诗级退化——全新的博客系统</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​六月月初换了个新电脑，准备把原来的hexo博客迁移过去，发现重新生成&#x2F;部署的时候产生了一些问题，正准备全部重新弄一遍。在找主题的时候确犯了强迫症。最后受到<a href="https://eklitzke.org/">https://eklitzke.org/</a>的启发，准备自己手撸一个。反正轮子也造习惯了，不差这一回。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>​反正是静态博客，也不需要啥后端，于是最后的设计目标就是根据markdown文件生成html文件，然后丢到github-pages上即可，也不刷要啥前端框架，能正常显示文件表格和图像即可。</p><p>​<strong>技术栈的选择</strong>。这整个流程最麻烦的一部就是Markdown生成Html，这一步也造轮子属实没必要，于是准备去github上找个开源库，一开始找的是<a href="https://github.com/mity/md4c">https://github.com/mity/md4c</a> 这个，编译也过了，确实能用，但是很难处理编码问题。最后又仔细想了想，这种工作用不着<code>C/C++</code>这种语言，随便整个脚本就行了。最后我选定了<a href="https://python-markdown.github.io/">https://python-markdown.github.io/</a> .果然，python在做这种不怎么需要性能的文本工作确实方便。</p><p>​<strong>简单的设计</strong>。由于不想把样式文件硬编码，就准备了一个目标<code>template.html</code>,将css的引用和markdown生成的内容填进去即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    %s<br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>%s<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        %s<br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-bottom&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-list&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../index.html&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://gitHub.com/hhhxiao&quot;</span>&gt;</span>GitHub<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就是这么个简单东西，<code>&lt;head&gt;</code>内填上css引用，然后<code>&lt;article&gt;</code>内填上使用<code>python-markdown</code>生成的文本文件即可。</p><p>​<strong>遇到的问题。</strong>整个过程遇到的最大问题就是生成的html中引用的css文件始终无法被edge识别，F12按烂了也找不到问题。这里就不得不承认Chrome才是真神了。当我打开chrome后发现css的内容竟然乱码了，这时候检查本地源文件才发现<strong>CSS和HTML的文件编码不匹配</strong>，而Edge的控制台自作聪明在显示css内容的时候偷偷变了编码。当然最后其实还是我的问题，没想到生成的html文件是<code>utf-16</code>编码的，和<code>utf-8</code>的css不匹配，这才导致了整个问题的产生。</p><p><strong>脚本的编写。</strong>在核心问题解决后剩下的就是体力活了，整个代码也就不到100行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ftplib <span class="hljs-keyword">import</span> all_errors<br><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> index<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time_ns<br><span class="hljs-keyword">from</span> tkinter.messagebox <span class="hljs-keyword">import</span> NO<br><span class="hljs-keyword">from</span> turtle <span class="hljs-keyword">import</span> ht<br><span class="hljs-keyword">import</span> markdown<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_style</span>(<span class="hljs-params">paths: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]</span>):<br>    res = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> paths:<br>        res += <span class="hljs-string">&#x27;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;%s&quot;&gt;\n&#x27;</span> % path<br>    <span class="hljs-keyword">return</span> res <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>(<span class="hljs-params">name:<span class="hljs-built_in">str</span></span>):<br>    text = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(name, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> input_file:<br>        text = input_file.read()<br>    <span class="hljs-keyword">return</span> text<br><br><span class="hljs-keyword">def</span><span class="hljs-title function_">write_file</span>(<span class="hljs-params">path:<span class="hljs-built_in">str</span>,conetent :<span class="hljs-built_in">str</span></span>):<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(conetent)<br><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_html</span>(<span class="hljs-params">input_makrdown:<span class="hljs-built_in">str</span>,style</span>):<br>    md = markdown.Markdown(extensions = [<span class="hljs-string">&#x27;meta&#x27;</span>,<span class="hljs-string">&#x27;extra&#x27;</span>,<span class="hljs-string">&#x27;codehilite&#x27;</span>,<span class="hljs-string">&#x27;md4mathjax&#x27;</span>])<br>    content = md.convert(input_makrdown)<br>    template = read_file(<span class="hljs-string">&#x27;template.html&#x27;</span>)<br><br>    time_meta = md.Meta.get(<span class="hljs-string">&#x27;date&#x27;</span>)<br>    time = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> time_meta <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        time = time_meta[<span class="hljs-number">0</span>]<br><br>    title_meta = md.Meta.get(<span class="hljs-string">&#x27;title&#x27;</span>)<br>    title = <span class="hljs-string">&quot;Welcome to hhhxiao&#x27;s blog&quot;</span><br>    <span class="hljs-keyword">if</span> time_meta <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        title = title_meta[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">return</span> template % (get_style(style) ,title ,content),time<br>    <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmp</span>(<span class="hljs-params">a,b</span>):<br>    ta = a[<span class="hljs-string">&#x27;time&#x27;</span>]<br>    tb = b[<span class="hljs-string">&#x27;time&#x27;</span>]<br>    <span class="hljs-keyword">if</span> ta &gt; tb:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> ta &lt; tb:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">input_path:<span class="hljs-built_in">str</span>,output_path:<span class="hljs-built_in">str</span></span>):<br>    all_files =  os.listdir(input_path)<br>    markdown_files = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> all_files <span class="hljs-keyword">if</span> x.endswith(<span class="hljs-string">&#x27;.md&#x27;</span>)]<br>    indexes = []<br>    csses = [<span class="hljs-string">&#x27;styles.css&#x27;</span>,<span class="hljs-string">&#x27;custom.css&#x27;</span>]<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> markdown_files:<br>        name = file[:-<span class="hljs-number">3</span>]<br>        markdown_path = input_path +<span class="hljs-string">&#x27;/&#x27;</span>+file<br>        <span class="hljs-built_in">print</span>(markdown_path)<br>        html,time = generate_html(read_file(markdown_path),[<span class="hljs-string">&#x27;../style/&#x27;</span> + x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> csses])<br>        write_file(output_path+<span class="hljs-string">&#x27;/posts/&#x27;</span>+name+<span class="hljs-string">&#x27;.html&#x27;</span>,html)<br>        <span class="hljs-comment">#index_markdown += &#x27;[%s] [%s](./posts/%s.html)\t\n&#x27; % (name,name)</span><br>        indexes.append(&#123;<span class="hljs-string">&#x27;time&#x27;</span>:time,<span class="hljs-string">&#x27;name&#x27;</span>: name &#125;)<br>    <br>    indexes = <span class="hljs-built_in">sorted</span>(indexes,key=functools.cmp_to_key(cmp))<br>    <br>    index_markdown = <span class="hljs-string">&quot;# AGNO3\n Welcome to hhhxiao&#x27;s blog\n\n&quot;</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> indexes:<br>        index_markdown += <span class="hljs-string">&#x27;  %s&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[%s](./posts/%s.html)&lt;br&gt;&#x27;</span> % (item[<span class="hljs-string">&#x27;time&#x27;</span>],item[<span class="hljs-string">&#x27;name&#x27;</span>],item[<span class="hljs-string">&#x27;name&#x27;</span>])<br>    index_html,_ = generate_html(index_markdown,[<span class="hljs-string">&#x27;style/&#x27;</span>+x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> csses])<br>    write_file(output_path+<span class="hljs-string">&#x27;/index.html&#x27;</span>,index_html)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) !=<span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;use py gen.py [input folder] [output folder]&quot;</span>)<br>        exit(-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">#path = &#x27;D:/blog/source/_posts&#x27;</span><br>    <span class="hljs-comment">#output = &#x27;./outputs&#x27;</span><br>    process(sys.argv[<span class="hljs-number">1</span>],sys.argv[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>当然目前写的还比较简陋，以后有时间就会慢慢完善。</p><p>每次写完后在博客根目录运行<code>python.exe .\gen.py  D:\nutSync\Blog\ ..</code>即可生成相关html文件了，然后手动commit加push就能自动部署到github-page上了，还是挺方便的，因为不需要编译前端代码，生成也非常快，至少比我之前的hexo快多了。当然缺点就是自己写的css比较丑，算了凑合看吧，小问题。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阻塞/非阻塞I/O以及Epoll</title>
    <link href="/posts/38bc/"/>
    <url>/posts/38bc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自 <a href="https://eklitzke.org/blocking-io-nonblocking-io-and-epoll">Blocking I&#x2F;O, Nonblocking I&#x2F;O, And Epoll (eklitzke.org)</a></p></blockquote><p>在这篇文章中，我想解释下当你使用非阻塞的IO(NO blocking I&#x2F;O)的时候发生了什么，具体来说我会解释如下几点：</p><ul><li>使用系统调用<code>fcntl</code>将文件描述符设置为<code>O_NONBLOCK</code>的语义</li><li>非阻塞I&#x2F;O和异步I&#x2F;O(asynchronous I&#x2F;O)的区别</li><li>为什么非阻塞I&#x2F;O经常和I&#x2F;O复用一起使用，如<code>select</code>,<code>epoll</code>,和<code>kqueue</code></li></ul><h3 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h3><p>在默认情况下，Unix系统的文件描述符都位于阻塞模式(Blocking Mode)中，这意味着相关的I&#x2F;O调用如<code>read()</code>,<code>write()</code>或者<code>connect()</code>会产生阻塞。下面我举一个十分简单的模式来理解这一点，考虑以下场景：你想从一个常规的TTY程序(就是普通的没GUI的控制台程序)的标准输入流(stdin)中读数据，在这种场景下<code>read()</code>会一直阻塞直到有实际的数据达到（比如用户输入数据并按下回车以刷新缓冲区）。具体来说，内核会让当前进程处于睡眠状态直到stdin中有数据可读。这个行为对于其他的文件描述符也是成立的，举个例子，如果你试图从TCP socket中读取数据，那么read()函数会一直阻塞直到对面往这里发送的数据到达。</p><p>阻塞的问题在于需要并发处理的场景下，因为被阻塞的进程会被挂起（这时候就无法利用CPU的资源只能一直等待，很影响并发性）。下面有两种方法以解决这个问题：</p><ul><li>非阻塞模式</li><li>使用IO端口复用的系统调用，如<code>select</code>和<code>epoll</code></li></ul><p>这两种是独立的解决方案，但是它们经常被放到一起使用。接下来我们来看一下这两种方法的区别以及为什么它们一般被放到一起用。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>可以通过<code>fcntl</code>函数来给文件描述符添加<code>O_NONBLOCK</code>以使其进入非阻塞模式(nonblocking mode)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* set O_NONBLOCK on fd */</span><br><span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);<br></code></pre></td></tr></table></figure><p>在设置为非阻塞模式后，**I&#x2F;O系统调用如<code>read</code>和<code>write</code>（在没有数据时）会返回-1，且会把<code>errno</code>设置为<code>EWOULDBLOCK</code>**。</p><p>这样的方式虽然看起来有点意思，但是实际上没啥用。 仅使用这个原语没法有效地来对多个文件描述符进行 I&#x2F;O操作。例如，假设我们有两个文件描述符并且想要一次读取它们。我们可以这样实现：在一个循环中检查每个文件描述符是否有数据，如果没有就让进程睡眠一段时间然后再次进行检查：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> sleep_interval&#123;.tv_sec = <span class="hljs-number">0</span>, .tv_nsec = <span class="hljs-number">1000</span>&#125;;<br><span class="hljs-type">ssize_t</span> nbytes;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">/* 尝试从fd1中读数据*/</span><br>    <span class="hljs-keyword">if</span> ((nbytes = <span class="hljs-built_in">read</span>(fd1, buf, <span class="hljs-built_in">sizeof</span>(buf))) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//没有数据</span><br>        <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK) &#123;<span class="hljs-comment">//等于就说明没数据，不等于就说明炸了</span><br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read/fd1&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//有数据，开始处理</span><br>        <span class="hljs-built_in">handle_data</span>(buf, nbytes);<br>    &#125;<br><br>    <span class="hljs-comment">/* 尝试从fd2中读数据，同上*/</span><br>    <span class="hljs-keyword">if</span> ((nbytes = <span class="hljs-built_in">read</span>(fd2, buf, <span class="hljs-built_in">sizeof</span>(buf))) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read/fd2&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">handle_data</span>(buf, nbytes);<br>    &#125;<br><span class="hljs-comment">/*两个都没数据，睡一会儿再尝试*/</span><br>    <span class="hljs-built_in">nanosleep</span>(sleep_interval, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的方法确实能用，但是有一堆缺点：</p><ul><li>当数据来的非常慢的时候，程序会被频繁唤醒，这样很浪费CPU资源</li><li>如果数据来的时候程序正好在睡眠，那么数据需要等一会才能被读到，这样会造成读延迟</li><li>代码编写繁琐，扩展性差</li></ul><p>为了解决这些问题，我们需要IO复用(I&#x2F;O multiplexer)</p><h3 id="I-x2F-O复用-select-epoll-kqueue等"><a href="#I-x2F-O复用-select-epoll-kqueue等" class="headerlink" title="I&#x2F;O复用(select, epoll, kqueue等)"></a>I&#x2F;O复用(select, epoll, kqueue等)</h3><p>​类Unix系统提供了几个I&#x2F;O复用的系统调用，如POSIX定义的<code>select</code>，Linux下的<a href="http://man7.org/linux/man-pages/man7/epoll.7.html">Epoll</a>,BSD下的<a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2">kqueue</a>.这些I&#x2F;O复用机制都在相同的模式下工作：</p><ol><li><p>提供一个接口让内核知道当前程序感兴趣的一组文件描述符以及绑定在每种文件描述符上的I&#x2F;O事件(通常是读取事件和写入事件)</p></li><li><p>提供一个接口，当程序调用这个接口时会一直阻塞直到它感兴趣的I&#x2F;O事件发生，当IO事件发生后该接口能返回程序感兴趣的相关事件的相关数据(如类型，描述符等)</p></li></ol><p>  举个例子,例如，你可以告诉内核你只对文件描述符 X 上的读取事件、文件描述符 Y 上的读取和写入事件以及文件描述符 Z 上的写入事件感兴趣。这些I&#x2F;O复用的接口并不关心文件描述符是处于阻塞模式还是非阻塞模式，处于阻塞模式的文件描述符在epoll或者select中照样能正常工作。如果**你只对 select 或 epoll 返回的文件描述符调用 <code>read() </code>和 <code>write()</code>，即使这些文件描述符处于阻塞模式，调用也不会阻塞(因为返回就意味着有数据)**。但是有一个例外，就是文件描述符的阻塞&#x2F;非阻塞状态对polling的触发模式来说十分重要，下面我会进一步解释。</p><p>​并发的多路复用方法就是我所说的异步IO(asynchronous I&#x2F;O)，有时候人们也管这叫非阻塞IO,我认为这是不懂系统编程级别非阻塞这个概念所导致的。我建议保留术语“非阻塞”来指代文件描述符是否实际上处于非阻塞模式。</p><h3 id="O-NONBLOCK-如何与-I-x2F-O-多路复用交互"><a href="#O-NONBLOCK-如何与-I-x2F-O-多路复用交互" class="headerlink" title="O_NONBLOCK 如何与 I&#x2F;O 多路复用交互"></a>O_NONBLOCK 如何与 I&#x2F;O 多路复用交互</h3><p>假设我们正在使用带有阻塞文件描述符的 select 编写一个简单的套接字服务器。 为简单起见，在此示例中，我们只有要从中读取的文件描述符，它们位于 read_fds 中。 事件循环的核心部分将调用 select，然后为每个带有数据的文件描述符调用一次 read：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">ssize_t</span> nbytes;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-comment">/*阻塞直到感兴趣的文件描述符有数据*/</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">select</span>(FD_SETSIZE, &amp;read_fds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;select&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-comment">//数据到了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(i, &amp;read_fds)) &#123;<br>            <span class="hljs-comment">/*检测到读事件发生*/</span><br>            <span class="hljs-keyword">if</span> ((nbytes = <span class="hljs-built_in">read</span>(i, buf, <span class="hljs-built_in">sizeof</span>(buf))) &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">handle_read</span>(nbytes, buf);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//阻塞模式下read返回值小于0说明read函数出错</span><br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这种方法不仅行得通而且还挺好的。 但是，如果 buf 很小，并且有大量的数据需要读，那么会发生什么呢？ 具体来说，假设 buf 是一个 1024 字节大小的缓冲区，但同时有 64KB 的数据需要读。 为了处理这个请求，我们会在调用 <code>select</code> 后接着调用<code>read()</code>64 次。，这总共会产生128个系统调用。</p><p>​如果缓冲区大小太小，则必须多次调用读取，这是无法避免的(read的调用次数&#x3D;数据量&#x2F;缓冲区大小)。 但或许我们可以减少调用 <code>select</code>的次数？ 在本例中的理想情况下，，我们想仅调用一次 select接口。</p><p>​事实上，我们可以通过将文件描述符置于非阻塞模式来实现这一想法。 基本思想是在循环中不断调用 read，直到它返回 EWOULDBLOCK。 就像下面的代码这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">ssize_t</span> nbytes;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">select</span>(FD_SETSIZE, &amp;read_fds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;select&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; FD_SETSIZE; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(i, &amp;read_fds)) &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//发现有数据直到读完位置</span><br>                nbytes = <span class="hljs-built_in">read</span>(i, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>                <span class="hljs-keyword">if</span> (nbytes &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">handle_read</span>(nbytes, buf);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK) &#123;<span class="hljs-comment">//读完了</span><br>                        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);                        <span class="hljs-comment">//出现问题</span><br>                        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​在这个例子中（1024 字节的缓冲区，有 64KB 的数据需要读取），我们将执行 66 次系统调用：一次select调用，64次没有错误的read调用以及一次返回数据已读完的read调用。这种方案下的总调用次数几乎是上一个示例的一半，能极大提高性能和可伸缩性。</p><p>​这种方法的缺点是由于循环的存在，至少会产生一次额外的读取，因为它会一直调用read直到返回 EWOULDBLOCK，如果缓冲区足够大，能够一次性将数据读完的话，这种方法会多产生一次read调用。</p><h3 id="边缘触发模式下的Polling"><a href="#边缘触发模式下的Polling" class="headerlink" title="边缘触发模式下的Polling"></a>边缘触发模式下的Polling</h3><p>​非阻塞 I&#x2F;O 还有一个更重要的用途：配合Epoll中的ET(edge-trigged，边沿触发)模式。 Epoll有两种模式：电平触发(Level-trigged,LT)和边沿触发两种模式。 LT模式是一种更简单的编程模型，类似于经典的 select 系统调用。 为了解释LT和ET的差异，我们需要了解 epoll 在内核中是如何工作的。</p><p>​假设你告诉内核你要使用 epoll 来监视你感兴趣的文件描述符上的I&#x2F;O事件, 内核就会为每个文件描述符维护这些感兴趣的I&#x2F;O事件列表。 当数据进入文件描述符(即相关的I&#x2F;O事件发生)时，内核遍历该列表并使用事件列表中的文件描述符唤醒每个在 <code>epoll_wait</code> 中阻塞的进程。</p><p>​无论 epoll 处于何种触发模式，我上面概述的情况都会发生。LT模式和ET模式之间的区别在于程序调用<code>epoll_wait </code>时内核中发生的情况不同。 在LT模式下，内核将遍历兴趣列表中的每个文件描述符，以查看它是否已经匹配兴趣条件。 例如，如果你在文件描述符 8 上注册了一个读取事件，当调用 <code>epoll_wait</code>时，内核将首先检查文件描述符 8 上否已经有数据，只要有数据那么 <code>epoll_wait </code>就会返回而不会阻塞。</p><p>​相比之下，在边ET发模式下，内核会跳过此检查，并在程序调用<code>epoll_wait</code>时立即使进程进入睡眠状态。 这把所有的责任都交给了你，程序员，做正确的事情，并在等待之前完全读取和写入每个文件描述符的所有数据。</p><p>这种边缘触发模式使 epoll 成为 O(1)级别的 I&#x2F;O 多路复用器：程序在调用epoll_wait后调会立即被挂起，当新数据进入内核时，内核会在 O(1) 时间内唤醒那个进程。</p><blockquote><p>个人理解：</p><p>LT模式下，程序调用<code>epoll_wait</code>就相当于询问内核自己关心的I&#x2F;O事件是否有数据，这个询问会一直阻塞到自己关心的I&#x2F;O事件到来（如果没有数据会阻塞）</p><p>ET模式下, 程序调用<code>epoll_wait</code>后就就会被内核挂起，当有IO事件发生后内核会主动唤醒该进程</p></blockquote><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>LT模式就是只要当前缓冲区状态下有数据就会触发内核的epoll_wait，类似数字逻辑中的高电平触发，ET模式是有新数据到来的时候才会触发内核事件，类似数字逻辑中的的始终上升沿触发。</p><p>有一个更有效的例子来说明ET和LT触发模式之间的区别。假设你的读取缓冲区是 100 字节，并且该文件描述符有 200 字节的数据进入。</p><p>在LT模式下你首先调用<code>epoll_wait</code>，进程会一直阻塞到有数据再返回，然后你读了100byte，接着你会再次调用<code>epoll_wait</code>,内核会发现还有100byte,然后该调用再次返回，你又读了100byte，读完后你继续调用<code>epoll_wait</code>,然后进程又开始阻塞，直到有新的数据。</p><p>​在ET模式下，内核会让你立即进入睡眠状态。当有200byte到来后，内核会马上唤醒你，叫你读数据。不管你有没有读完，因为没有新的数据到了，内核也不会再通知你，所以<strong>你就必须在内核通知的那一次内读完所有数据.<strong>由于</strong>阻塞模式下的IO无法判定数据有没有读完，且如果read()在阻塞的时候有新的数据来到,那么当前进程就会错过内核的这次有数据的通知</strong>,然后整个IO程序就死锁了,因ET模式需要配合非阻塞模式。</p>]]></content>
    
    
    <categories>
      
      <category>系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言的运行时</title>
    <link href="/posts/3fbd/"/>
    <url>/posts/3fbd/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode解题记录(1)</title>
    <link href="/posts/d8b4/"/>
    <url>/posts/d8b4/</url>
    
    <content type="html"><![CDATA[<p>作业太多不想做，把最近在leetcode上做的题稍微总结一下，既然标题写了1，就说明还是想把这个做成一个系列的。</p><h3 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><a href="https://leetcode-cn.com/problems/JEj789/">粉刷房子</a></h3><p>基础的dp题，从上往下挨个算最小值即可，时间O(n)，空间O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;<br>           <span class="hljs-keyword">if</span> (costs.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> row = costs.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        costs[i][<span class="hljs-number">0</span>] += <span class="hljs-built_in">min</span>(costs[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], costs[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>        costs[i][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(costs[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], costs[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>        costs[i][<span class="hljs-number">2</span>] += <span class="hljs-built_in">min</span>(costs[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], costs[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span>&amp; l = costs.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">min</span>(&#123;l[<span class="hljs-number">0</span>], l[<span class="hljs-number">1</span>], l[<span class="hljs-number">2</span>]&#125;);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="字符串中的变味词"><a href="#字符串中的变味词" class="headerlink" title="字符串中的变味词"></a><a href="https://leetcode-cn.com/problems/MPnaiL/">字符串中的变味词</a></h3><p>这题关键是计算<strong>位置无关的哈希</strong>,并且要注意一点哈希不一定要是一个数字，只要<strong>能代表这个字符串位置无关的特征即可</strong>，这里是采用最偷懒的字符计数方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>           <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() &gt; s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pattern, cur_pat;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        pattern[s1[i]]++;<br>        cur_pat[s2[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pattern == cur_pat) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s2.<span class="hljs-built_in">size</span>() - s1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">auto</span> iter = cur_pat.<span class="hljs-built_in">find</span>(s2[i - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">1</span>) &#123;<br>            cur_pat.<span class="hljs-built_in">erase</span>(s2[i - <span class="hljs-number">1</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur_pat[s2[i - <span class="hljs-number">1</span>]]--;<br>        &#125;<br>        cur_pat[s2[s1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> + i]]++;<br>        <span class="hljs-keyword">if</span> (cur_pat == pattern) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度</a></h3><p>最基础的利用单调栈的题了。时间空间都是O(n)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>            std::vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; stack;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(temperatures.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> x = temperatures[i];<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; stack.<span class="hljs-built_in">back</span>().first &lt; x) &#123;<br>           <span class="hljs-comment">// printf(&quot;%d &lt; %d\n&quot;, stack.back().first, x);</span><br>            res[stack.<span class="hljs-built_in">back</span>().second] = i - stack.<span class="hljs-built_in">back</span>().second;<br>            stack.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        stack.<span class="hljs-built_in">push_back</span>(&#123;x, i&#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache-lcci/">LRU缓存</a></h4><p>由于LRU(最近最少使用)算法涉及到对列表的随机增删，因此这里使用链表作为数据的载体，哈希表作为快速查询的工具使用，这里使用了C++的<code>std::list</code>,要十分注意其迭代器失效问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-comment">//test</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123; <span class="hljs-keyword">this</span>-&gt;cap = capacity; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> iter = <span class="hljs-keyword">this</span>-&gt;cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (iter == cache.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> value = iter-&gt;second-&gt;second;<br>        list.<span class="hljs-built_in">erase</span>(iter-&gt;second);<br>        list.<span class="hljs-built_in">insert</span>(list.<span class="hljs-built_in">begin</span>(), &#123;key, value&#125;);<br>        cache[key] = list.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">//找到有没有这个键对应的值</span><br>        <span class="hljs-keyword">auto</span> iter = <span class="hljs-keyword">this</span>-&gt;cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (iter == cache.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">//没有找到就插入</span><br>            <span class="hljs-keyword">this</span>-&gt;list.<span class="hljs-built_in">insert</span>(list.<span class="hljs-built_in">begin</span>(), &#123;key, value&#125;);<br>            <span class="hljs-comment">//更新迭代器</span><br>            <span class="hljs-keyword">this</span>-&gt;cache[key] = list.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-comment">//如果超了就移除最后一个</span><br>            <span class="hljs-keyword">if</span> (list.<span class="hljs-built_in">size</span>() &gt; cap) &#123;<br>                <span class="hljs-comment">//获取键的值</span><br>                <span class="hljs-keyword">auto</span> last = list.<span class="hljs-built_in">back</span>().first;<br>                list.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-comment">//擦除</span><br>                cache.<span class="hljs-built_in">erase</span>(last);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//找到了,擦除旧的，并挪动到头部</span><br>            list.<span class="hljs-built_in">erase</span>(iter-&gt;second);<br>            <span class="hljs-keyword">this</span>-&gt;list.<span class="hljs-built_in">insert</span>(list.<span class="hljs-built_in">begin</span>(), &#123;key, value&#125;);<br>            <span class="hljs-keyword">this</span>-&gt;cache[key] = list.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br><br>   <span class="hljs-keyword">private</span>:<br>    std::list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; list;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; cache;<br>    <span class="hljs-type">int</span> cap;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何手动解压压缩包(雾)--GZ文件格式详解</title>
    <link href="/posts/7f79/"/>
    <url>/posts/7f79/</url>
    
    <content type="html"><![CDATA[<h1 id="如何手解压缩包（雾）–GZIP-文件结构"><a href="#如何手解压缩包（雾）–GZIP-文件结构" class="headerlink" title="如何手解压缩包（雾）–GZIP 文件结构"></a>如何手解压缩包（雾）–GZIP 文件结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个GZIP文件主体分为三个部分,如下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[header]</span><span class="hljs-selector-attr">[deflate block|...]</span><span class="hljs-selector-attr">[header]</span><br></code></pre></td></tr></table></figure><p>其中头部是元数据，中间是deflate的压缩数据块，尾部是固定<code>8byte</code>的元数据，接下来具体详细地介绍这三个部分。</p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>和其他格式一样，Gzip文件的头部定义了该文件的元数据信息。该部分的长度不固定，至少10byte大小，其格式如下表所示：</p><table><thead><tr><th>Offset</th><th>Size(byte)</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>2</td><td><code>.gz</code>格式的魔数，一定为<code>0x1f 0x8b</code></td></tr><tr><td>2</td><td>1</td><td>使用的压缩算法，0x8表示使用deflate，其他值暂时不合法</td></tr><tr><td>3</td><td>1</td><td>File flag</td></tr><tr><td>4</td><td>4</td><td>时间戳</td></tr><tr><td>8</td><td>1</td><td>压缩flag</td></tr><tr><td>9</td><td>1</td><td>操作系统flag,3表示<code>unix</code></td></tr><tr><td>10</td><td>未知</td><td>依据File flag的格式而定</td></tr></tbody></table><p>这个flag定义了header中超过10字节的部分的含义，依据不同的值，其表示的含义也不同。一般来说File flag的值都是<code>0x08</code>，表示了header中10byte偏移之后的部分是文件名（使用C风格字符串表示，读到0为止）。</p><h2 id="Deflate-Block"><a href="#Deflate-Block" class="headerlink" title="Deflate Block"></a>Deflate Block</h2><p>紧接着<code>header</code>之后的就是Deflate压缩块序列。</p><blockquote><p>注意</p><ol><li>这里讨论的是<strong>动态霍夫曼编码压缩块</strong>的结构，静态和不压缩的deflate block由于比较简单这里不再详述，感兴趣的读者可以参考相关RFC。</li><li>在读取相关信息时要提前将数据流以字节单位的小端序处理。如读出来的内容是 <code>111110000  11001111....</code>,后面实际进行处理的序列为<code>00001111 11110011</code>。</li><li>deflate压缩块之间和<strong>都不会进行字节对齐</strong>。</li></ol></blockquote><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>一个deflate压缩块依次包含如下五个部分，<strong>每个部分之间不会进行字节对齐</strong>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[ Deflate block metadata   ]<br>[ Huffman<span class="hljs-symbol">&#x27;s</span> code table     ]<br>[  encoded huffman table   ] <br>[  Compressed content      ]<br></code></pre></td></tr></table></figure><p>其中Deflate block metadata 给出了块内的一些元数据，而Huffman’s  code table给出了解码霍夫曼编码表的编码表， encoded huffman table是被编码过的霍夫曼编码表，用于实际内容的解码，Compressed content就是实际的编码后的内容。</p><h3 id="Deflate-tree"><a href="#Deflate-tree" class="headerlink" title="Deflate tree"></a>Deflate tree</h3><p>为了能看懂整个压缩块的结构，这里需要首先介绍deflate使用的编码算法，该算法是huffman编码的一个变种，可以使用更少的信息构建一颗霍夫曼树，以下将这种变种的huffman树称之为<strong>deflate 树</strong>。</p><p>传统的霍夫曼编码表是这样的：</p><table><thead><tr><th>值</th><th>编码</th></tr></thead><tbody><tr><td>2</td><td>01</td></tr><tr><td>3</td><td>001</td></tr><tr><td>4</td><td>000</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>对于编码本身而言，霍夫曼编码唯一的规定是<strong>任意两个编码都不会构成前后缀的关系</strong>.</p><p>而deflate使用的编码表是这样的：</p><table><thead><tr><th>值</th><th>长度</th></tr></thead><tbody><tr><td>2</td><td>3</td></tr><tr><td>3</td><td>1</td></tr><tr><td>4</td><td>2</td></tr></tbody></table><p>可以看到，deflate编码表并没有规定每个值的具体编码，而是只规定了每个值的编码的长度。在deflate的规则下，<strong>算法能够根据每个值的长度信息计算处每个值的唯一编码且保证任意两个编码都不会构成前后缀关系</strong>。</p><p>deflate定义的额外规则如下所示：</p><ul><li>对于同编码长度的所有值，它们的编码按照值的大小依次递增。举个例子，如果规定值2 4 3的编码都是3位，且2的编码是<code>000</code>的话，那么3的编码是<code>000+1 = 001</code>，4的编码值是<code>000+2=010</code>。</li><li>n位长的最小编码的值等于n-1位长的编码的最大值加上1然后左移一位。接着上面的例子，如果规定1，5的编码长度是4位，那么1的编码就是<code>(010+1)&lt;&lt;1 =0110</code></li></ul><p>在以下两条规则下，程序就能根据每个值的编码长度为每个值定义编码了。下面举个例子来复现上述过程，如果定义字符1 2 3 4 5 6 7 8这8个字符的编码长度分别为3 3 3 3 3 2 4 4，那么编码计算过程如下所示：</p><ol><li><p>统计每种长度的编码出现的次数：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"> <span class="hljs-comment">N   值     出现次数</span><br><span class="hljs-literal">-</span>  <span class="hljs-literal">------</span> <span class="hljs-comment"></span><span class="hljs-literal">--------</span><br><span class="hljs-comment">2    6      1</span><br><span class="hljs-comment">3    1 2 3 4 5      5</span><br><span class="hljs-comment">4    7 8            2</span><br></code></pre></td></tr></table></figure></li><li><p>依据规则2计算每种长度内的最小编码</p><p>这里每种长度的最小编码就是计算6 1 7的编码(分别为 2 3 4位下的最小值)。</p><p>计算过程如下所示</p><ol><li>首先定义1位长度的最大编码为0</li><li>2位的最小编码为<code>(1+1) &lt;&lt; 1 = 0 &lt;&lt; 1 = 00 </code>，2位的最大编码也是<code>00</code>(只有6这一个数字，最大最小也一样) </li><li>3位的最小编码为<code>(00+1)&lt;&lt;1 = 01 &lt;&lt;1 = 010</code>,3位的最大编码位<code>010+5-1=110</code></li><li>4位的最小编码为<code>(110+1)&lt;&lt;1 = 1110</code></li></ol></li><li><p>依据规则1计算其它编码，得到的表如下所示：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">Symbol Length   Code</span><br><span class="hljs-literal">------</span> <span class="hljs-literal">------</span>   <span class="hljs-literal">----</span><br><span class="hljs-comment">1       3        010</span><br><span class="hljs-comment">2       3        011</span><br><span class="hljs-comment">3       3        100</span><br><span class="hljs-comment">4       3        101</span><br><span class="hljs-comment">5       3        110</span><br><span class="hljs-comment">6       2         00</span><br><span class="hljs-comment">7       4       1110</span><br><span class="hljs-comment">8       4       1111</span><br></code></pre></td></tr></table></figure></li></ol><p>在介绍上面的算法后就能看懂deflate压缩块的结构了。</p><p>如果不清楚细节的话至少需要明确一点：<strong>一个编码表是一个&lt;值，编码长度&gt;的列表</strong>。</p><h3 id="Deflate-block-metadata"><a href="#Deflate-block-metadata" class="headerlink" title="Deflate block metadata"></a>Deflate block metadata</h3><p>块内元数据这一部分固定只有1+2+5+5+4&#x3D;17个bit，下表给出了这个17个bit每一部分的偏移，大小和含义。</p><table><thead><tr><th>偏移<br>(相当当前块的开头)</th><th>符号表示</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>BFINAL</td><td>1</td><td>当前是否为最后一个deflate块</td></tr><tr><td>1</td><td>BFINAL</td><td>2</td><td>压缩类型</td></tr><tr><td>3</td><td>HLIT</td><td>5</td><td>字面量&#x2F;长度编码的个数-257</td></tr><tr><td>8</td><td>HDIST</td><td>5</td><td>距离编码的个数-1</td></tr><tr><td>13</td><td>HCLEN</td><td>4</td><td>霍夫曼表编码的个数-4</td></tr></tbody></table><blockquote><p>注意读取这些数据后要进行反向，如读出来压缩类型是01时要反向成为10</p></blockquote><p>压缩类型一共有4个值：</p><ul><li>00 不压缩</li><li>01 使用内置的霍夫曼编码做压缩</li><li>10 使用动态霍夫曼编码进行压缩</li><li>11 保留不使用</li></ul><p>HLIT，HDIST，HCLEN这三个值定义了各种情况下需要读出的编码个数，用到时再详细解释。</p><h3 id="Huffman’s-code-table"><a href="#Huffman’s-code-table" class="headerlink" title="Huffman’s  code table"></a>Huffman’s  code table</h3><p>该部分的长度为<code>(HCLEN+4)*3</code> bit.</p><p>这部分是用于解码霍夫曼编码表的<strong>编码表</strong>。由于RFC规了这个编码表面的值(值是什么含义看后面)序列固定为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>,<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>因此压缩快中只给出了上述序列前<code>(HCLEN+4)</code>个值对应的编码长度，每个长度信息固定为3bit。</p><p>举个例子,如果HCLEN &#x3D; 8,那么我们就需要从块内读取(8+4)*3&#x3D;36个bit且如下所示，形成如下的编码表(码长需要逆转编码)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">Bit</span> 码长值<br><span class="hljs-attribute">011</span><span class="hljs-number">6</span><span class="hljs-number">16</span><br><span class="hljs-attribute">111</span><span class="hljs-number">7</span><span class="hljs-number">17</span><br><span class="hljs-attribute">111</span><span class="hljs-number">7</span><span class="hljs-number">18</span><br><span class="hljs-attribute">110</span><span class="hljs-number">3</span><span class="hljs-number">0</span><br><span class="hljs-attribute">110</span><span class="hljs-number">3</span><span class="hljs-number">8</span><br><span class="hljs-attribute">010</span><span class="hljs-number">2</span><span class="hljs-number">7</span><br><span class="hljs-attribute">110</span><span class="hljs-number">3</span><span class="hljs-number">9</span><br><span class="hljs-attribute">110</span><span class="hljs-number">3</span><span class="hljs-number">6</span><br><span class="hljs-attribute">001</span><span class="hljs-number">4</span><span class="hljs-number">10</span><br><span class="hljs-attribute">001</span><span class="hljs-number">4</span><span class="hljs-number">5</span><br><span class="hljs-attribute">101</span><span class="hljs-number">5</span><span class="hljs-number">11</span><br><span class="hljs-attribute">001</span><span class="hljs-number">4</span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>得到这张码表后就能根据上文提到的算法算出每一个值的编码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">010</span>: <span class="hljs-number">0</span><br><span class="hljs-attribute">1100</span>: <span class="hljs-number">4</span><br><span class="hljs-attribute">1101</span>: <span class="hljs-number">5</span><br><span class="hljs-attribute">011</span>: <span class="hljs-number">6</span><br><span class="hljs-attribute">00</span>: <span class="hljs-number">7</span><br><span class="hljs-attribute">100</span>: <span class="hljs-number">8</span><br><span class="hljs-attribute">101</span>: <span class="hljs-number">9</span><br><span class="hljs-attribute">1110</span>: <span class="hljs-number">10</span><br><span class="hljs-attribute">11110</span>: <span class="hljs-number">11</span><br><span class="hljs-attribute">111110</span>: <span class="hljs-number">16</span><br><span class="hljs-attribute">1111110</span>: <span class="hljs-number">17</span><br><span class="hljs-attribute">1111111</span>: <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>这张表会用于后续霍夫曼编码表读取。</p><h3 id="encoded-huffman-table"><a href="#encoded-huffman-table" class="headerlink" title="encoded huffman table"></a>encoded huffman table</h3><p>到了这里终于可以读取霍夫曼编码表了，该表分<strong>字面量&#x2F;长度编码</strong>表和<strong>距离编码表</strong>两个部分，其编码个数分别为HLIT+257以及HDIST+1。</p><h4 id="字面量-x2F-长度编码表"><a href="#字面量-x2F-长度编码表" class="headerlink" title="字面量&#x2F;长度编码表"></a>字面量&#x2F;长度编码表</h4><p>使用上一节提供的编码表遍历接下来的字节流，并生成一个编码长度序列<code>L</code>，该序列的生成规则如下所示：</p><ol><li>如果值x在0-15内，那么往<code>L</code>中加入x即可</li><li>如果值x &#x3D;&#x3D; 16,那么需要往后读2bit的扩展值e，并将<code>L</code>内的最后一个值重复(e+3)次</li><li>如果值x &#x3D;&#x3D; 17,那么需要往后读3bit的扩展值e,并往<code>L</code>中加入(e+3)个0</li><li>如果值x&#x3D;&#x3D;18,那么需要往后读7bit的扩展值e,并往<code>L</code>中加入(e+11)个0</li></ol><p>直到序列长度为HLIT+257为止。</p><p>这个HLIT+257长度的值就是<code>[0, HLIT+257)</code>这些值的编码长度。</p><p>也就是说，字面量&#x2F;长度编码表如下所示：</p><table><thead><tr><th>值</th><th>长度</th></tr></thead><tbody><tr><td>0</td><td>L[0]</td></tr><tr><td>1</td><td>L[1]</td></tr><tr><td>…</td><td>…</td></tr><tr><td>n</td><td>L[n]</td></tr><tr><td>…</td><td>….</td></tr></tbody></table><p>使用这个表便可以构造<code>[0,HLIT+257)</code>中非0值的编码。</p><h4 id="距离编码表"><a href="#距离编码表" class="headerlink" title="距离编码表"></a>距离编码表</h4><p>在读完字面量&#x2F;长度编码表后，使用完全相同的方法读取HDIST+1个编码长度即可。形成的编码表和上方完全相同。</p><p>使用这个表便可以构造<code>[0,HDIST+1)</code>中非0值的编码。</p><h3 id="Compressed-content"><a href="#Compressed-content" class="headerlink" title="Compressed content"></a>Compressed content</h3><p>到目前为止终于读出并计算出来两类数据的编码了。下面介绍如何根据这两种霍夫曼编码来读取实际的内容。</p><p>这部分比较简单，使用<strong>字面量&#x2F;长度编码</strong>从压缩块中读数据，从上文可知，这个数据x的范围是<code>[0,HLIT+257)</code>，对于该数据的大小，我们做如下判定：</p><ul><li><p>如果<code>0 &lt;= x &lt;= 255</code>，我们认为它是一个ascii字符，作为LZ7编码串的字面量部分存在</p></li><li><p>如果<code>257&lt;=x&lt;HLIT+257</code>,我们认为这是一个匹配对的距离，并根据x的值读取不同长度的扩展位以计算具体的长度下，每个值对应的扩展位的长度如下表所示：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Extra               Extra               Extra<br>Code Bits Length(s) Code Bits Lengths   Code Bits Length(s)<br>---- ---- ------     ---- ---- -------   ---- ---- -------<br>257   0     3       267   1   15,16     277   4   67<span class="hljs-string">-82</span><br>258   0     4       268   1   17,18     278   4   83<span class="hljs-string">-98</span><br>259   0     5       269   2   19<span class="hljs-string">-22</span>     279   4   99<span class="hljs-string">-114</span><br>260   0     6       270   2   23<span class="hljs-string">-26</span>     280   4  115<span class="hljs-string">-130</span><br>261   0     7       271   2   27<span class="hljs-string">-30</span>     281   5  131<span class="hljs-string">-162</span><br>262   0     8       272   2   31<span class="hljs-string">-34</span>     282   5  163<span class="hljs-string">-194</span><br>263   0     9       273   3   35<span class="hljs-string">-42</span>     283   5  195<span class="hljs-string">-226</span><br>264   0    10       274   3   43<span class="hljs-string">-50</span>     284   5  227<span class="hljs-string">-257</span><br>265   1  11,12      275   3   51<span class="hljs-string">-58</span>     285   0    258<br>266   1  13,14      276   3   59<span class="hljs-string">-66</span><br></code></pre></td></tr></table></figure><p>举个例子，如果x &#x3D; 273,那么我们需要往后读3bit的值e，然后e+35作为这个匹配对的长度<code>len</code></p><p>读取完拓展1位后需要<strong>使用距离编码读取这个匹配对的距离d</strong>，并根据d取值的不同读取相应的扩展位以计算具体的长度，每个d值对应的扩展位以及计算方法如下所示：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Extra           Extra               Extra<br>Code Bits Dist  Code Bits   Dist     Code Bits Distance<br>---- ---- ----  ---- ----  ------    ---- ---- --------<br>0   0    1     10   4     33<span class="hljs-string">-48</span>    20    9   1025<span class="hljs-string">-1536</span><br>1   0    2     11   4     49<span class="hljs-string">-64</span>    21    9   1537<span class="hljs-string">-2048</span><br>2   0    3     12   5     65<span class="hljs-string">-96</span>    22   10   2049<span class="hljs-string">-3072</span><br>3   0    4     13   5     97<span class="hljs-string">-128</span>   23   10   3073<span class="hljs-string">-4096</span><br>4   1   5,6    14   6    129<span class="hljs-string">-192</span>   24   11   4097<span class="hljs-string">-6144</span><br>5   1   7,8    15   6    193<span class="hljs-string">-256</span>   25   11   6145<span class="hljs-string">-8192</span><br>6   2   9<span class="hljs-string">-12</span>   16   7    257<span class="hljs-string">-384</span>   26   12  8193<span class="hljs-string">-12288</span><br>7   2  13<span class="hljs-string">-16</span>   17   7    385<span class="hljs-string">-512</span>   27   12 12289<span class="hljs-string">-16384</span><br>8   3  17<span class="hljs-string">-24</span>   18   8    513<span class="hljs-string">-768</span>   28   13 16385<span class="hljs-string">-24576</span><br>9   3  25<span class="hljs-string">-32</span>   19   8   769<span class="hljs-string">-1024</span>   29   13 24577<span class="hljs-string">-32768</span><br></code></pre></td></tr></table></figure><p>举个例子，如果d &#x3D; 9,那么我们需要往后读3bit的值e，然后e+25作为这个匹配对的匹配距离<code>distance</code></p><p>读取完<code>&lt;len,distance&gt;</code>后这部分就结束了</p></li><li><p>如果<code>x == 256</code>表示这个gzip压缩块结束了。</p></li></ul><h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><p>在读完最后一个压缩块后，就进入了footer部分，由于压缩块不是字节对齐的，因此这里需要往后填充1-7个0直到字节对齐然后读取footer。footer固定为8byte,其中前4byte为文件的CRC32校验码，后4字节为原始未压缩文件的大小。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://datatracker.ietf.org/doc/html/rfc1951">RFC 1951 - DEFLATE Compressed Data Format Specification version 1.3 (ietf.org)</a></li><li><a href="http://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art001">Dissecting the GZIP format (commandlinefanatic.com)</a></li><li><a href="https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art053">A Completely Dissected GZIP File (commandlinefanatic.com)</a></li><li><a href="http://staff.ustc.edu.cn/~yuzhang/ds/gzip/gzip_principle.htm">gzip实现源代码分析 (ustc.edu.cn)</a></li><li><a href="https://docs.fileformat.com/compression/gz/">https://docs.fileformat.com/compression/gz/</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TLS/SSL如何保证HTTPS协议的安全</title>
    <link href="/posts/fe87/"/>
    <url>/posts/fe87/</url>
    
    <content type="html"><![CDATA[<h1 id="TLS-x2F-SSL如何保证HTTPS协议的安全"><a href="#TLS-x2F-SSL如何保证HTTPS协议的安全" class="headerlink" title="TLS&#x2F;SSL如何保证HTTPS协议的安全"></a>TLS&#x2F;SSL如何保证HTTPS协议的安全</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>  1999年6月，万维网协会(W3C)和互联网工程任务组（IETF）共同发布了RFC2616，这份标准规范化了接下来20年里十分重要的一个协议–HTTP。HTTP协议是一个客户端和服务端之间进行请求和应答的标准，能够让客户端使用标准的方式从服务器内获取各种资源，如HTML，数字图像等等。</p><p>  虽然HTTP得到了广泛的使用，但是HTTP的安全行性难以得到保证。攻击者可以通过监听和中间人攻击等手段获取网站账户和敏感信息。为了解决这一问题，1994年网景公司首次提出了HTTPS协议，该协议可在使用适当的加密包以及服务器证书可被验证和信任时，对窃听和中间人攻击提供合理的防护。</p><p>  HTTPS协议的原理是在HTTP与传输层（如TCP）之间建立一条可靠安全套接层(SSL)。该层的主要任务是提供私密性和身份认证。后来IETF在SSLv3的基础上做了一定的修改，形成了TLS，即安全传输协议。安全的传输协议建立在密文传输的基础上，下面从加密和及身份认证技术两个方面来叙述TLS&#x2F;SSL为HTTP提供的防护措施。</p><h3 id="加密和身份认证"><a href="#加密和身份认证" class="headerlink" title="加密和身份认证"></a>加密和身份认证</h3><h4 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h4><p>从密钥划分的角度上来说，加密分为对称加密和非对称加密两种。非对称加密的加密和解密采用的是同一串密钥，用户使用同一个私钥可以同时加密和解密明文和密文，常见的对称加密算法有AES和DES等等。与之不同的非对称加密的</p><p>密钥分为公钥和私钥两种，使用公钥加密的密文只有使用私钥才能解密，反之亦然。常见的非对称加密算法有RSA等等。</p><p>相对非对称加密来说，对称加密的效率要高得多，但是由于难以对密钥进行分发和管理，因此对称加密的安全性更低。而非对称加密恰恰相反，发布者只需发布公钥，别人即可使用公钥加密明文并将密文发送给发布者，发布者可以用私钥对密文进行解密。整个流程中私钥完全不会泄露，这也体现了非对称加密更高的安全性。但是非对称加密的加解密的时间长，速度慢，只适合加解密少量数据。</p><p>TLS&#x2F;SSL协议结合了这两者的优点：使用对称加密来加解密实际数据，而使用非堆成加密来加密对称密钥。这样既能保证加解密的速度，又能解决密钥的分发问题。</p><h4 id="身份认证和数字证书"><a href="#身份认证和数字证书" class="headerlink" title="身份认证和数字证书"></a>身份认证和数字证书</h4><p>上述非对称加密的公私钥体系虽然能保证信息的私密性，但是无法做到身份认证。考虑这样一种情况：存在一个第三者发送了假的公钥给客户端，然后用这个假公钥对应的私钥给客户端发送信息以欺骗客户端。此时的客户端完全不知道与自己通信的服务端是假冒的。这个场景下的关键问题是，服务器如何证明自己的身份，数字证书的存在解决了这一问题。</p><p>所谓的数字证书，就是首先要确立一个足够信任的第三方C，C使用自己的私钥对服务器S提供的公钥做加密，然后服务器再将加密后的公钥发送给客户端，客户端使用C提供的公钥对加密后的服务器公钥做解密，如果能正常解密就说明第三方C证明了服务器S的身份，这样就解决了服务器的身份认证问题。该过程的流程图如图所示：</p><p><img src="https://tvax4.sinaimg.cn/mw690/007bwgzIgy1h1ar6eode4j30e607zgm4.jpg" alt="image"></p><p>在实际的数字证书体系中，这个受信的第三方被称之为证书授权中心（CA），服务器交给CA进行加密的除了自己的公钥外还包括一些其它的如组织名字，有效期等等其它用于身份证明的信息，加密后的相关数据被赋予了一个新的名字—数字证书。SSL&#x2F;TLS中采用了数字证书的方法对服务器或客户端做身份验证。</p><p>接下来将详细叙述SSL&#x2F;TLS如何利用加密技术和数字证书技术来提供安全的信道。</p><h3 id="SSL-x2F-TLS-安全传输层的建立"><a href="#SSL-x2F-TLS-安全传输层的建立" class="headerlink" title="SSL&#x2F;TLS****安全传输层的建立"></a>SSL&#x2F;TLS****安全传输层的建立</h3><p>客户端和服务端之间安全信道的建立分为四个阶段，如下图所示。下面将对这四个结算分别进行介绍。</p><p><img src="https://tva3.sinaimg.cn/mw690/007bwgzIgy1h1ar5ixw8nj30fl0fkgnn.jpg" alt="image"></p><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p>在CS(客户端-服务端)模式下，首先发起通宵的一般都是客户端，因此提出建立SSL连接的也是客户端。客户端（通常是浏览器）首先向服务器发送一个需要进行加密通信的请求，该信息被称之为ClientHello。在该步骤中，客户端主要向服务端提供如下的信息:</p><ol><li><p>客户端支持的SSL&#x2F;TLS协议版本；</p></li><li><p>支持加密套件。所谓的加密套件，就是一套流程中会使用到的加密算法，如RSA等等。客户端会向服务器发送自己所知道的所有加密套件，但是最终采用哪一种完全取决与服务器的选择；</p></li><li><p>一个由客户端生成的随机数，该数字会用于后面的密钥生成。</p></li></ol><h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>阶段二的主要行为是服务器应答。服务器在收到客户端的问候消息后会对其提供的协议版本，支持的加密算法等信息做检查，如果服务器接受所有条件，则会向客户端发送SeverHello消息，以及如下的内容：</p><ol><li><p>本次会话中要使用的协议版本。服务器会从客户端提供的协议版本选择一个接下来使用的具体版本信息，用于本次会话的协议规范；</p></li><li><p>从客户端提供的加密套件中选择一个接下来要使用的加密套件；</p></li><li><p>服务器证书。服务器会将事先从CA中申请的证书发送给客户端，关于证书的原理详见2.2节，这里不再赘述。</p></li><li><p>一个由服务器生成的随机数，该随机数同样会被用来生成密钥。</p></li></ol><p>至此，客户端和服务端已经约定了如下信息：本次会话使用的协议版本、接下来要使用的加密算法、以及由双方生成的随机数。</p><h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><p>客户端在收到服务端发送的回应后，会首先使用CA提供的凭据验证其证书，如果证书不是由可信机构颁发，或者证书中出现其包含的服务器信息与实际的信息不一致等问题，客户端就会认为该服务器不可信进而给用户发出警告或直接中断通信。如果证书没有出现问题客户端则会向服务器发送如下信息：</p><ol><li><p>由服务器的公钥加密的pre master key。该值的生成方式以及内容由具体的加密套件而定，如果采用的是RSA加密，那么该值则为客户端生成的一个随机数。双方会使用该pre master key以及之前产生的两个随机数共同生成消息传输过程中使用的对称密钥，该密钥用于后面所有实际内容的对称加密；</p></li><li><p>消息改变通知，该通知的含义是告知服务器接下来的所有消息都用约定好的加密套件和密钥进行加密传输。</p></li><li><p>客户端结束握手的消息，该消息会包含之前发的所有消息的哈希值，用于交给服务器进行校验。</p></li></ol><h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><p>服务端在收到客户端发送的pre master key后也会使用与客户端相同的方法计算本次会话使用的对称密钥，接着向客户端发送如下消息以结束信道的建立工作：</p><ol><li><p>消息改变通知，表示随后的信息都将使用双方使约定的加密算法加密后再发送；</p></li><li><p>服务端的结束握手消息，和客户端一样，该通知也包含之前所有消息的哈希值，用于交给客户端进行校验。</p></li></ol><p>至此，双方就在HTTP协议之下建立起了一个可以安全通信的信道，将不安全的HTTP封装成为了相对安全的HTTPS。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>  安全性总是相对的。TLS&#x2F;SSL所能提供的保护也受到浏览器的实现以及服务端软件所支持的加密算法等因素的影响。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gzip是如何压缩文件的</title>
    <link href="/posts/87b6/"/>
    <url>/posts/87b6/</url>
    
    <content type="html"><![CDATA[<h2 id="Gzip-是如何工作的"><a href="#Gzip-是如何工作的" class="headerlink" title="Gzip 是如何工作的"></a>Gzip 是如何工作的</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Gzip使用<code>deflate</code>算法对数据流进行压缩，该算法分1-9一共9个压缩等级，等级越低压缩率越低压缩速度越快。下面使用默认的6级来来说明。<code>Deflate</code>算法该分为LZ77和霍夫曼编码两个部分：前者负责压缩，后者负责编码（其实编码和压缩是一个意思）这里使用字符串<code>abcabcaaabaaa</code>为例来描述算法的总体流程：Gzip首先使用LZ77算法来对该字符串做压缩，得到如下的LZZ编码串（括号和逗号只是为了方便理解，不包括在LZZ编码串内）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abc</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)</span><span class="hljs-title">aaab</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)</span></span><br></code></pre></td></tr></table></figure><p>这其中的abc就是表示直接把原来的abc复制过来，<code>(4,3)</code>表示从该位置前方4个字符开始往后的三个字符赋值到当前位置，也就是重复一次abc。在这样一个串中，称abc为未匹配的字符串字面量，简称字面量。<code>(distance,length)</code>称为一个有序匹配对，简称匹配对，其中distance表示距离，length表示匹配串的长度。</p><p>​</p><p>下面针对这两个部分做详细解释。</p><h3 id="LZ77算法"><a href="#LZ77算法" class="headerlink" title="LZ77算法"></a>LZ77算法</h3><p>在gzip的实现中，LZ77需要对一个串找最短匹配长度为3的匹配长度最长的匹配串（也就是最长的相同子串，但是要求最短长度为3）gzip使用数组实现了一个小型的哈希表，哈希的key是根据子串的前三个字符算出来的一个哈希值（这里为方便起见直接使用字符串本身作为哈希值），value是一个链，链中展示了所有以这个三个字符开始的字串的首字母下标位置，下标越大越排在前面。以</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">[a a b c a a b c]<br>[0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6 7]<br></code></pre></td></tr></table></figure><p>为例，其哈希表是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[aab]</span> --&gt;<span class="hljs-selector-attr">[4]</span>-&gt;<span class="hljs-selector-attr">[0]</span><br><span class="hljs-selector-attr">[abc]</span> --&gt;<span class="hljs-selector-attr">[5]</span>-&gt;<span class="hljs-selector-attr">[1]</span><br><span class="hljs-selector-attr">[bca]</span> --&gt;<span class="hljs-selector-attr">[2]</span><br><span class="hljs-selector-attr">[caa]</span> --&gt;<span class="hljs-selector-attr">[3]</span><br></code></pre></td></tr></table></figure><p>后面的匹配过程都是根据这个哈希表来完成。当算法扫描到第一个<code>aab</code>时候，发现<code>aab</code>对应的哈希链是空的，也就是说一定不存在与之相匹配的串，就将其插入哈希表中。持续这样操作直扫描到第二个<code>aab</code>时，算法发现该哈希对应的链上已经链接了其它的字符串，这说明前面已经出现过字符串<code>aab</code>了，于是这里可以得到一个匹配对<code>(4,3)</code>，表示该位置前面存在一个长度为3的相同串。但是这时候算法还不能确定<code>(4,3)</code>就是最后的匹配，因为后面可能还有更长的。这里算法使用了懒惰匹配算法：当出现一个的匹配后，算法不会直接确定该匹配，直到下一个匹配比当前匹配更短，这时候就确定上一个匹配为最佳匹配，并将其写入LZ77编码串中。</p><p>这里LZ77规定匹配串的最小长度是3，最大长度是258。</p><p>每当向LZ77编码串写入一个字符串字面或者写入一个匹配对，Gzip就会对该串频率统计以方便后面的霍夫曼编码。当达到以下条件时算法会对当前的LZ77编码串做一次霍夫曼编码：</p><p>这里首先定义<strong>LZ77编码串的长度为:字符串字面量的个数+匹配对的个数</strong></p><ol><li><p>每当<code>len(lz77_string) % 4096 = 0</code>时（也就是编码串的长度达到一次4096时）进行一次的判定：</p><ol><li>预估的压缩数据的长度小于原始长度的一半（这里的预估是使用一种有较多的冗余编码方法对编码串进行编码后的输出长度）</li><li>匹配对的个数少于未匹配对的个数</li></ol><p>如果以上两个条件都满足，就当前编码串的所有内容进行霍夫曼编码，并清空LZ77编码串缓存。</p></li><li><p>每次LZ77编码串接收新的字符串字面量或者匹配对时：</p><p>如果LZ77串的长度(字符字面量的个数+匹配对的个数达到了32767)或者匹配对的个数达到了32768就进行一次刷洗，将当前的LZ77压缩串传给霍夫曼编码。</p></li></ol><h3 id="霍夫曼编码实现"><a href="#霍夫曼编码实现" class="headerlink" title="霍夫曼编码实现"></a>霍夫曼编码实现</h3><p>前面已经说到，gzip会分别采用静态和动态编码对LZ77压缩串进行压缩，两者唯一的区别是前者如使用内置的固定编码对LZ77的字符串字面量和匹配对进行编码，并将压缩数据写入压缩文件，而后者则使用根据串的频率信息计算出来的编码。</p><p>对于静态编码，内置的编码是什么样的这里不做过多赘述。下面简单叙述一下动态编码的规则。</p><p>gzip把字面量和匹配的长度放到一棵霍夫曼树中，这些一共有286个节点：</p><ol><li>0-255：对应<code>0x00-0XFF</code>中的256种byte</li><li>256：一共霍夫曼压缩块的结束标记</li><li>257-285表示匹配长度的29个范围。由于匹配长度的范围为[3,258],因此这里这里把<code>258+3-1=256</code>个匹配串的长度分配给这29个编码中（实际的编码后面会再跟特定的bit序列来表明具体是哪个值），具体如何分配的这里不再赘述。</li></ol><p>而gzip对距离编码则采用一棵单独的有30个叶子节点的树进行编码，由于距离长度的范围是<code>[1,32768]</code>,因此这里也要把32768个距离值分配到这个30个叶子节点中，也和匹配长度一样，编码后面会跟随特定的比特序列来确定具体是哪一个距离值。由于在接收LZ77编码那个步骤中已经完成了基本的频率统计，因此霍夫曼编码这一步就是根据频率统计信息构建一棵特殊的霍夫曼树，并根据树结构赋予不同的叶子节点不同的编码即可。</p><p>最后gzip依次将或父母编码的元数据(包括编码信息和编码类型等)写入压缩文件,并写入编码后的数据和结束标记，这样就完成了一个压缩数据块的写入工作。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://staff.ustc.edu.cn/~yuzhang/ds/gzip/gzip_principle.htm">http://staff.ustc.edu.cn/~yuzhang&#x2F;ds&#x2F;gzip&#x2F;gzip_principle.htm</a></p><p><a href="https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art053">https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art053</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单的RPC框架设计和实现</title>
    <link href="/posts/fcfe/"/>
    <url>/posts/fcfe/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>YA-RPC框架（下称本框架）是一个采用C++17编写的简易RPC框架。本框架支持integer,float,string,bool等数据类型，并支持根据服务定义生成相应的RPC服务端代码。</p><h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h2><p>  本框架主要分RPC服务端和代码生成器两个部分，其中前者提供RPC服务的基础设施，后者根据开发者定义的服务来生成相应的服务代码供给服务端使用。下图展示了本框架的顶层设计：</p><p><img src="https://tva4.sinaimg.cn/mw690/007bwgzIgy1gx8ldcv5btj30l208b3zd.jpg" alt="image"></p><p>  服务定义由库使用者自己编写，类似于GRPC的proto文件，为了简便起见，这里使用了较为通用和易于读写的<code>json</code>格式。代码生成器通过读取服务定义来生成服务代码文件，服务代码文件会预留空白的函数体给库使用者编写具体的服务。库使用者可以在自定义的RPC服务端中添加由代码生成器的服务。</p><p>  为了便于服务端和客户端之间的消息传递，这里直接使用了<code>websocket</code>来作为消息传输的底层协议。<code>websocket</code>是定义在http协议上层的自带连接的可靠的应用层协议，可以在一定程度上保证消息能够顺利地在客户端和服务端之间传输而不容易丢失。</p><p>  为了使用RPC服务端提供的服务，客户端需要首先和RPC服务端建立连接，然后发送特定格式的包含必要信息的消息给服务端，服务端会调用服务并把结果传送给客户端。这样便完成了一次RPC调用。</p><p>本文编译运行和测试相关环境和使用第三方库如下表所示：</p><table><thead><tr><th>项目</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>编程语言</td><td>C++17</td><td></td></tr><tr><td>操作系统</td><td>Linux</td><td>64位操作系统</td></tr><tr><td>第三方库</td><td>uWebsockets, nlohmann::json</td><td>均为github的开源仓库</td></tr><tr><td>其它辅助语言</td><td>shellscript,python</td><td>用于辅助测试</td></tr><tr><td>整个框架的详细设计见下一节。</td><td></td><td></td></tr></tbody></table><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="服务和消息"><a href="#服务和消息" class="headerlink" title="服务和消息"></a>服务和消息</h3><p>  一个RPC服务端应当支持多种服务，每个服务应当支持一种或多种方法，每种方法都有自己的参数列表和返回值类型。因此这里采用如下的<code>json</code>格式来定义一个服务:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;String&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Uppercase&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;str&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;string&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;return&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  其中<code>name</code>定义了服务的名字，<code>method</code>定义了该服务提供的所有方法（函数）列表。列表中的每一项就是一个具体的函数。这样在抽象的层面上，客户端就可以用类似<code>rpc-service.method(args...)</code>的方法来唯一定位自己要调用的服务。因此这里顺便给出客户端的消息（也就是RPC请求）格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;service&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;String&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Uppercase&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;str&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello World&quot;</span>   <br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  其中<code>client</code>是客户端标识，用于给服务端做身份验证和日志记录等工作，本框架为方便期间未使用该字段。<code>service</code>和<code>method</code>定义了客户端想要使用的服务，<code>params</code>给出了该服务所需的参数列表。</p><h3 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h3><p>服务端主要有<code>websocket</code>服务端、工作线程列表、服务列表这三个部分。RPC服务端运行时会监听特定端口，在收到该请求后会对参数进校验和验证，如果失败会直接给客户端发送一个失败的响应，如果成功会尝试调用对应的服务，并把结果封装在成功响应中并发送给客户端，下图展示了服务端的工作流程：</p><p><img src="https://tvax4.sinaimg.cn/mw690/007bwgzIgy1gx8lcnq9m0j30960eigme.jpg" alt="image"></p><p>由于服务端有多个线程，因此其在调用服务的时候不会阻塞IO（在请求不是十分繁忙的时候），下图展示了响应消息的格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HELLO WORLD&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  <code>code</code>表示响应的类型，为0的时候表示服务调用成功，结果在<code>result</code>中，不为0的时候表示RPC调用失败，不同的<code>code</code>值代表了不同的错误原因：</p><table><thead><tr><th>状态码</th><th>信息</th></tr></thead><tbody><tr><td>0</td><td>成功</td></tr><tr><td>1</td><td>消息格式错误</td></tr><tr><td>2</td><td>未找到服务</td></tr><tr><td>3</td><td>未找到方法</td></tr><tr><td>4</td><td>身份校验失败</td></tr><tr><td>5</td><td>服务调用超时</td></tr></tbody></table><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>  由于语言和语义上的原因，RPC无法做到通用的运行时服务生成的功能（某些支持反射的语言或者某些脚本语言除外）。因此需要预先使用第三方程序根据定义来生成代码。对于每个名为<code>Sample</code>的服务都会生成<code>SampleService.h</code>,<code>SampleService.cpp</code>和<code>SampleServiceStub.h</code>三个文件。其中<code>SampleServiceStub</code>是提供给RPC服务端的接口。一个典型的<code>SmapleServiceStub</code>文件如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringServiceStub</span> : <span class="hljs-keyword">public</span> RpcServiceStubInterface &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">StringServiceStub</span><span class="hljs-params">()</span> : RpcServiceStubInterface(<span class="hljs-string">&quot;String&quot;</span>) &#123;</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">RegisterMethods</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UppercaseStub</span><span class="hljs-params">(<span class="hljs-type">const</span> json &amp;params, RpcResponse &amp;response)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      std::string str = params[<span class="hljs-string">&quot;str&quot;</span>].<span class="hljs-built_in">get</span>&lt;std::string&gt;();<br>      <span class="hljs-keyword">auto</span> c = stringService.<span class="hljs-built_in">Len</span>(str);<br>      response.result[<span class="hljs-string">&quot;result&quot;</span>] = c;<br>    &#125; <span class="hljs-built_in">catch</span> (std::exception &amp;e) &#123;<br>      response.result[<span class="hljs-string">&quot;result&quot;</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterMethods</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  StringService stringService;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>  服务中每个具体的方法<code>Method</code>都有一个对应的<code>MethodStub</code>方法，该方法负责将<code>json</code>格式的参数列表解析成对应参数类型的参数列表，由于这部分无法运行时完成，因此也是使用代码生成最主要的原因。在完成参数解析后会将参数传递给由<code>SampleService.h</code>中定义的实际服务。<code>SampleService.h</code>和<code>SampleService.cpp</code>中的内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//SampleSerivce.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringService</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Len</span><span class="hljs-params">(std::string str)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//sampleService.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;StringService.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StringService::Len</span><span class="hljs-params">(std::string str)</span> </span>&#123;<br>    <span class="hljs-comment">//供库使用者填写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  其中CPP文件是空白的函数体，供给库使用者填写具体的服务实现。框架还编写了一个安装脚本<code>install.sh</code>，在管理员权限下可将其安装到系统目录，方便测试使用。</p><h2 id="测试和分析"><a href="#测试和分析" class="headerlink" title="测试和分析"></a>测试和分析</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>  本章节使用单精度浮点类型的求和函数和字符串的转大写服务来进行测试。这里定义前者在<code>Arithmetic</code>服务中，而后者定义在<code>String</code>服务中，两个服务的定义文件如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;String&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Uppercase&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;str&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Abc&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;return&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;abc&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Arithmetic&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Sum&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;b&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;return&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  并在这两个<code>json</code>所在的目录下运行如下的命令来生成每个服务的源码文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/opt/rpcgen . Test<br></code></pre></td></tr></table></figure><p>  其中<code>rpcgen</code>即为本框架的代码生成器，第二个参数<code>.</code>表示查找当前目录下的定义文件，<code>Test</code>表示该RPC服务器的名称。</p><p>  然后定义<code>TescRpcServer</code>继承自本框架提供的<code>RPCServer</code>基类并添加上方生成的两个服务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRPCServer</span> : <span class="hljs-keyword">public</span> RpcServer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestRPCServer</span>(<span class="hljs-type">size_t</span> t, <span class="hljs-type">uint16_t</span> port) : <span class="hljs-built_in">RpcServer</span>(t, port) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">AddService</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArithmeticServiceStub</span>());<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">AddService</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringServiceStub</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>  测试的客户端使用由python编写的简单WS客户端做测试，客户端会随机生成测试用例并在本地计算结果，然后将结果和服务端返回的结果做比对，如果二者结果相同就认为该测试用例测试通过。为了测试并发性，这里同时运行4个客户端来向RPC服务端发消息。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>下方选取了部分测试结果（客户端输出）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs log">=========SUM TEST==========<br>[112.25968170166016 == 112.25967970499761] ==&gt; Passed<br>[46.3238639831543 == 46.3238626744408] ==&gt; Passed<br>[77.39429473876953 == 77.39429371831518] ==&gt; Passed<br>[82.80653381347656 == 82.80652726251887] ==&gt; Passed<br>...<br>All sum test passed<br>======UPPERCASE TEST=======<br>[BI0QPGTR == BI0QPGTR] ==&gt; Passed<br>[XDUENYVR == XDUENYVR] ==&gt; Passed<br>[M9PBLKHS == M9PBLKHS] ==&gt; Passed<br>[U8N4KFAK == U8N4KFAK] ==&gt; Passed<br>...<br>All sum test passed<br></code></pre></td></tr></table></figure><p>  测试结果显示所有的测试通过。</p><h2 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  本文借用了第三方的<code>websocket</code>和<code>json</code>库实现了简单的RPC框架，并使用多个客户端通过了测试。</p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>  本次实现的RPC框架还非常简陋，还有很大的改进空间，如：</p><ol><li>不支持自定义的数据类型或者结构体</li><li>在可靠性语义上没有做到明确的区分和定义</li><li>在TCP的基础上做消息传递</li><li>其它等等</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>P=NP?--算法复杂性和NP问题概述</title>
    <link href="/posts/c8e9/"/>
    <url>/posts/c8e9/</url>
    
    <content type="html"><![CDATA[<h3 id="问题和多项式时间"><a href="#问题和多项式时间" class="headerlink" title="问题和多项式时间"></a>问题和多项式时间</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>​在开始了解P&#x3D;NP之前需要首先知道“问题”是什么。这里首先对“问题”做一个形式化的定义:<strong>抽象问题Q为问题实例集合I和题解S上的一个二元关系。</strong>例如，对于排序问题的一个实例是：n个正整数和排列顺序(升序或者降序)，题解则为一个有效的排列。</p><p>​为了简单期起见,NP完全性理论只关注<strong>判定问题</strong>,即题解$S&#x3D;{0,1}$的问题，因此这里可以定义判定问题为<strong>从问题实例集合到题解$S&#x3D;{0,1}$的一个二元关系，</strong>当然也能直接叫函数关系,即$ s &#x3D; Q(i),s \in {0,1}$ .</p><h4 id="编码和多项式复杂度"><a href="#编码和多项式复杂度" class="headerlink" title="编码和多项式复杂度"></a>编码和多项式复杂度</h4><p>​编码就是对问题规模的一个形式化的定义。定义抽象集合S(问题实例集合就是一个抽象集合)的编码为S到二进制串集合的映射。在定义编码后，我们就可以对任意一个问题实例i做编码得到其编码$e(i)$.编码$e(i)$的长度就是所谓的问题规模。</p><p>​如果当提供给算法的是编码长度为$n &#x3D; |e(i)|$的问题实例i时，算法可以在$O(T(n))$时间内产生问题的解，就说该算法在时间$O(T(n))$内解决完了问题i,特别地，如果$T(n) &#x3D; n^k$，我们就说该问题是多项式时间内可解的。</p><blockquote><p>注：这里确实挺抽象的，但是仔细想想也不难，主要是把各种各样的问题统一编码称二进制串以便计算机进行解决。</p><p>举个几个例子(自己的理解不一定对)：</p><ol><li>对于整数排序问题：我们把输入的n个数字每个数都编码为32为的二进制串（即计算机中<code>int</code>型整数），一共有n个整数，因此编码总长度是n*32 &#x3D; 32n，在分析复杂性时候常熟往往是不重要的，因此可以认为该问题的输入规模就是n</li><li>对于问题有n个输入$a_1,a_2,…a_n$的问题P,存在一个可在$O(a_nn)$时间内解决该问题的算法，但是该算法<strong>并不能说是多项式时间内可解</strong>的，因为$a_n$不是编码n的一部分，算法的实际运行时间不仅依赖输入规模n，也依赖编码的实际内容$a_n$,因此是假的多项式时间复杂度。</li></ol></blockquote><h3 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h3><p>​在理解完问题后就能知道什么叫P问题了。定义<strong>复杂类P</strong>为多项式时间内可解的具体判定问题的集合。</p><blockquote><p>说人话就是对于一个(判定)问题，如果存在一个多项时间的算法能够将其解决就称该问题为<strong>P类问题</strong>。比如常见的数组排序，最短路径等等。</p></blockquote><p>注意<strong>P是一个问题集合。</strong></p><h3 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h3><blockquote><p>这里没有用形式化表述是因为设计到一些形式语言的知识，懒得深入了。</p></blockquote><p>​对于一个问题X以及它的一个解C，如果存在一个多项式时间的算法能够验证C确实是X的一个解，则称此类问题为<strong>NP类问题</strong>，或者叫NP问题。比如对于问题“给定数组<code>3 1 2 4 5</code>，求它的一个升序排列“，以及这个问题的一个解<code>C = 1 2 3 4 5</code>，这里很容易（可在多项式时间内）验证排列C是原数组的一个升序排列，因此该问题是一个NP类问题。</p><p>​<strong>定理</strong> $P \subseteq NP$，即<strong>一个P问题一定是一个NP问题</strong>。</p><p>​这个定理是很显然的，用求解P问题的一个多项式算法来求出问题P的所有解，并把待验证解和解集合比对即可。</p><h3 id="NP完全性与NPC问题"><a href="#NP完全性与NPC问题" class="headerlink" title="NP完全性与NPC问题"></a>NP完全性与NPC问题</h3><h4 id="规约和NPC"><a href="#规约和NPC" class="headerlink" title="规约和NPC"></a>规约和NPC</h4><p>这里首先定义<strong>问题X能在多项式时间内规约到问题Y</strong>:对于问题X的任意实例x，都能在多项式时间内构造一个问题y的实例使得如果y输出为真时x也输出为真。该规约过程也记为$X \leq _pY $。</p><p>这里谈谈对这句话的理解，由于Y是在X的基础上在多项式时间内转化而来的，因此如果能够解决Y那就一定能解决X了(先把问题X转化为Y，再解决Y就能得到X的一个解）,且<strong>解决问题Y的算法一定不比问题X简单</strong>：</p><ul><li><p>如果Y是P问题，存在一个多项式算法Q，那么解决X的算法就是多项式时间的规约步骤+Q，结果还是多项式算法，因此Q也是P问题。</p></li><li><p>如果Y不是P问题，那么不存在一个多项式算法Q，但是这里X可能可以不用规约到Y就能有多项式算法，当然也可能没有，因此Q可能是P问题也可能不是。</p></li></ul><p>这就是规约采用$\leq$而不是$&#x3D;$的原因了。</p><p>在前面我们知道NP问题只有多项式时间的验证算法而不一定有解决算法。在知道规约的概念后，我们自然会想到，存不存在一个问题<code>Y</code>，能让所有的NP问题X都规约到Y,然后再把问题Y解决，那么所有的NP问题不就都解决了吗？</p><p>巧了，这样的问题还真有，也就是人们常说的<strong>NPC问题</strong>，也叫NP完全问题，下面给出该问题的标准定义：</p><p><strong>对于NP问题Y,如果对于任意的NP问题X，都有$X \leq_p Y$,那么Y被称为NPC问题。</strong></p><p>既然满足我们要求的所有问题都能在多项式时间内规约到Y的问题有了，那我们在多项式时间内解决它不就行了吗？只能说还是太天真了。到目前位置，没有人能证明NPC问题能在多项式时间内解决，也没人能证明不能。</p><p><strong>定理</strong> <strong>对于NPC问题Y，P能在多项式时间内解决当且仅当P&#x3D;NP</strong></p><p>下面给出证明：</p><ol><li>&lt;&#x3D;&#x3D; 如果P&#x3D;NP,因为Y是NP问题所以Y也是P问题，所以Y能在多项式时间内解决</li><li>&#x3D;&#x3D;&gt; 如果Y能在多项式时间内解决，所以Y是P问题，所以$NP \subseteq P$，又因为$P \subseteq NP$,所以$P&#x3D; NP$</li></ol><p>这就是所谓的P&#x3D;NP问题。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>谈谈对分布式系统的理解</title>
    <link href="/posts/8d2b/"/>
    <url>/posts/8d2b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇已经是00.20了，本来打算10点开始写的，但是<del>空洞骑士太好玩了</del>。研一上这学期吃饱了撑的选了一门课《分布式系统》，结果每周两节课都是早上第一节，搞得我几乎一节课没去，但是没办法试还得考，所以花了一点时间拜读了《分布式系统概念和设计》的部分内容，下面的内容全是有感而发，不会设计相关的算法细节。</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​自从互联网被发明以来，这个世界就进入了信息时代。随之而来的就是海量的数据需要维护和存储，量级更大的计算任务需要处理，这些都给传统的计算机带来的全新的挑战：单个计算机已经无法胜任海量的任务了。于是分布式系统这个领域就应运而生了。</p><p>​在我的理解中，分布式系统就是让多个独立的主机(或者说进程)共同协作，完成传统的单个计算机无法完成的任务。“完成”</p><p>一词看似轻巧，但是认真想想会产生一大堆传统单机器不会出现的问题，如：</p><ol><li>如何保证效率</li><li>如何保证多机的可靠性</li><li>如何方便这个多机系统的伸缩阔扩展</li></ol><p>这些都是一个成熟的分布式系统需要考虑的问题，下面我将慢慢叙述从这些性质发散和得出的一些问题、知识和算法等等。</p><h3 id="通信，资源，事务"><a href="#通信，资源，事务" class="headerlink" title="通信，资源，事务"></a>通信，资源，事务</h3><p>​人与人协作需要交流，计算当然也需要，计算机的这种”交流“被称之为通信。我们很自然地就能想到，计算机通信需要因特网的参与，但是这并不是我们关注的重点，我们的重点是更上层的东西。举一个例子，A计算机有一条很重要的信息要通告给这个系统的其它所有信息，并且需要这些信息作出回应，这里的问题是如何保证A发出的消息能准确地到达其它所有信息。再比如一个系统需要产生一个代表计算机A做整个系统的日志收集并发送给管理员，这种机制在分布式系统中被称为“选举”，也是需要解决的问题。</p><p>​资源访问是多机系统协作不能避免的问题。从”资源“这个词我们很容易就能想到的是分布式互斥问题：如何正确地分配一份（或者多份）临界资源给分布式系统？如何避免计算机在争夺资源的过程中发生死锁？如何才能让每个计算机都能公平地对独占资源进行访问而不被饿死？</p><p>​”并发“是多机器系统的不可避免的问题，在涉及到数据读写的问题时就更是如此。假设两个系统A和B”并发地“向计算机C提交一个事务，如何保证这两个并发事务的ACID特性？加锁？还有更好的方法吗？事务调度也是分布式系统（所有的存在并发的系统）中很重要的问题，除了简单加锁外，还有乐观并发控制，时间戳事务控制法等等，每种方法都有自己的优缺点和使用场景。</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>​一个成熟的分布式系统仅仅是”能运行“肯定是不够的（当然在任何软件中都是如此）。我们应当假设一个分布式系统中每台计算机都不是绝对可靠的，每一台都有故障的可能性（这在现实中是完全合理的）。如果有一天某台计算机突然故障导致数据无法被访问，通信也是永远的timeout,如何保证这个系统还能正常工作呢；再比如说在一个选举过程中，有部分系计算故障产生了错误的值，如何保证这个分布式系统的其它正常的计算机能够”纠正“这个错误呢。对于前者，冗余的计算机是一个很好的方案，但是这也会带来新的问题，如何保证这两台计算机的数据能够始终保持同步呢，对于后者也有一个很著名的”拜占庭将军问题“可供读者参考。</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>​这里列举的问题只占一小部分，现实中还会出现诸如网络分块、RPC、时钟同步、一致性等各种各样的问题，可以说设计一个高效可靠的分布式系统绝对不是简单的事情，《分布式系统概念和设计》这本书也只能起到一个抛砖引玉的作用。</p>]]></content>
    
    
    <categories>
      
      <category>系统结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>写一个简单的用户态文件系统</title>
    <link href="/posts/da79/"/>
    <url>/posts/da79/</url>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>本项目是仿照Linux下的ext4文件系统所编写的一个十分简单的用户态文件系统。本系统用标准的C99编写，在Linux下编译运行通过。本系统做了如下的工作：</p><ol><li>利用普通文件来模拟磁盘，文件系统对磁盘的所有操作均会映射到该文件(下文均简称磁盘文件)上；</li><li>磁盘文件可以随时持久化到本地以及从磁盘加载到内存；</li><li>本文件系统模拟了ext文件系统的超级块，I-node节点表，数据块的bitmap以及数据块表四个部分，所有上层操作都是对这四个部分进行读写；</li><li>本文件系统支持磁盘的创建、格式化、以及文件的创建、写内容和读内容。</li></ol><p>下一节介绍了本文件系统的概要以及详细设计。</p><h3 id="2-概要设计"><a href="#2-概要设计" class="headerlink" title="2. 概要设计"></a>2. 概要设计</h3><p>本文件系统采用分层设计的原则，从底至顶一共分为下面四个层级:</p><ol><li>磁盘布局层。该层提供了对I-node和数据块的创建和销毁的功能以及对超级块的读写功能；</li><li>I-node节点层。该层封装了对i-node的各种操作，包括修改和维护i-node的索引节点以及各种元数据维护。除此之外，该层还提供了对I-node索引的数据块进行数据读写的功能；</li><li>调用接口层。该层向上层提供了创建文件，向文件写入内容和读写内容，以及查看当前目录中文件列表的接口；</li><li>应用层。该层为用户提供了操作磁盘的交互式终端。</li></ol><p>下图展示了本文件系统的基本架构:</p><p><img src="https://tva4.sinaimg.cn/mw690/007bwgzIgy1gwru5ui8cej3046090dfw.jpg" alt="image"></p><h3 id="3-详细设计"><a href="#3-详细设计" class="headerlink" title="3. 详细设计"></a>3. 详细设计</h3><h4 id="3-1-磁盘布局"><a href="#3-1-磁盘布局" class="headerlink" title="3.1 磁盘布局"></a>3.1 磁盘布局</h4><p>本文设计的磁盘布局如下图所示:</p><p><img src="https://tva2.sinaimg.cn/mw690/007bwgzIgy1gwru6d0wdrj30jc01hq2x.jpg" alt="image"></p><p>​其中超级块(super block)记录了磁盘的元数据，包括每个i-node的大小、i-node的数量、空闲的i-node的数量、每个数据块元数据的大小、每个数据块的大小、磁盘大小等信息。在本系统中，数据块大小固定为1024B。</p><p>​在初始化一个磁盘时，系统会根据磁盘大小来计算i-node以及数据块的数量，遵循的原则是令i-node占据整个磁盘约1%的空间。为确保不存在碎片空间，系统在实际创建的磁盘时会对磁盘大小做微调。因此创建的磁盘实际大小与用户出入有细微出入。除此之外，每个i-node以及数据块会被分配一个唯一的id以便在需要时进行索引。</p><h4 id="3-2-I-node读写"><a href="#3-2-I-node读写" class="headerlink" title="3.2 I-node读写"></a>3.2 I-node读写</h4><p>本系统中i-node的结构如下图所示:</p><p><img src="https://tva4.sinaimg.cn/mw690/007bwgzIgy1gwru6psxyvj30du0aeab7.jpg" alt="image"></p><p>   I-node包含了文件的各种元数据以及数据块的位置，其中元数据包括i-node节点号，是否被占用，文件模式(类型，权限信息)，用户id，用户组id,修改时间以及链接个数等信息。对于数据块索引，本系统采用直接索引，一级索引和二级索引这三种方式来记录数据块的位置，其中直接索引一共有12个，后面两种间接索引各有一个。一个i-node节点号是8Byte的无符号整数，因此一个1024B的数据块可以存储1024&#x2F;8&#x3D;128个块索引，由此可得本文件系统支持的最大文件大小为(128*128+128 + 12) *1024 &#x3D; 16.137MB。</p><p>与此同时，i-node还维护了一个索引指针，用来指向最后一个指向数据块的索引，以便对数据块的内容进行读写。索引指针就是数据块的块号，磁盘根据块号来读写数据块。</p><p>在初始化磁盘的时候，系统会默认将0号i-node作为根目录”&#x2F;“的节点号,并为其分配一个数据块用于存储”..”和”.”这两个目录表项。由于本系统暂不支持多级目录，因此每创建一个文件都会在0号i-node的数据块上增加一个文件表项目。每个文件表项记录了文件的名字以及其对应的i-node节点号，其大小为128B,其中文件名占据120B，而I-node节点号占据8B。</p><h4 id="3-3-调用接口"><a href="#3-3-调用接口" class="headerlink" title="3.3 调用接口"></a>3.3 调用接口</h4><p>调用接口层提供了创建文件，读写文件内容的接口。创建文件主要分为两个步骤：</p><ol><li>申请分配一个空闲的的i-node，向该i-node中写入包括文件类型在内的各种元数据；</li><li>将文件名和申请得到的i-node节点号构成的文件表项写入0号i-node的数据块中.</li></ol><p>而对于写文件，系统首先获取该文件所对应的i-node最后一个数据块的指针，然后向其中追加内容，如果数据块被写完就为该i-node分配一个新的数据块，并更新i-node相关数据即可。而对于读文件，原理相似：首先从inode中获取第一个数据块的指针，然后依次遍历属于该i-node的所有数据块，读取内容并存到buffer即可。</p><h4 id="3-4-Shell"><a href="#3-4-Shell" class="headerlink" title="3.4 Shell"></a>3.4 Shell</h4><p>为方便使用，本系统基于上述接口开发了一个简单的shell，并支持如下命令:</p><ol><li><code>init [num]</code>: 创建一个大小为<code>num</code>KB的磁盘并进行格式化</li><li><code>ls</code>列出根目录下的所有文件以及其元数据信息</li><li><code>touch [file]</code>创建一个空文件</li><li><code>cat [file]</code>根据文件名读取该文件的内容并输出到终端</li><li><code>write [file]</code>将从终端标准输入流读取的数据写入文件</li><li><code>save [disk]</code>将磁盘文件保存到本地</li><li><code>load [disk]</code>加载本地磁盘的文件</li><li><code>info</code> 获取磁盘的详细信息，包括每个已经分配的i-node和数据块的内容以及超级块的信息等。</li></ol><p>详细的数据结构见附录。</p><h3 id="4-总结和展望"><a href="#4-总结和展望" class="headerlink" title="4. 总结和展望"></a>4. 总结和展望</h3><p>本系统实现了磁盘布局，文件的创建和读写等功能，完成了要求的任务。但是仍有很大的提升空间，如增加多级目录等功能。</p><h3 id="5-附录"><a href="#5-附录" class="headerlink" title="5. 附录"></a>5. 附录</h3><p>下面展示了各个对象的数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *超级块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block_t</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> magic_number; <span class="hljs-comment">//魔数</span><br>    <span class="hljs-type">uint16_t</span> size_of_sb;  <span class="hljs-comment">//超级块的大小</span><br>    <span class="hljs-type">uint16_t</span> size_of_inode; <span class="hljs-comment">//inode大小</span><br>    <span class="hljs-type">uint16_t</span> size_of_bi; <span class="hljs-comment">//数据块元数据大小</span><br>    <span class="hljs-type">uint16_t</span> size_of_block; <span class="hljs-comment">//数据块大小</span><br><br>    <span class="hljs-type">uint32_t</span> total_i_cnt; <span class="hljs-comment">//inode数量</span><br>    <span class="hljs-type">uint32_t</span> total_b_cnt; <span class="hljs-comment">//数据块数量</span><br>    <span class="hljs-type">uint32_t</span> free_i_cnt; <span class="hljs-comment">//空闲的inode数量</span><br>    <span class="hljs-type">uint32_t</span> free_b_cnt; <span class="hljs-comment">//空闲的数据块数量</span><br>    <span class="hljs-type">uint32_t</span> disk_size;  <span class="hljs-comment">//磁盘大小</span><br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数据块元数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_info_t</span> &#123;</span><br>    <span class="hljs-type">bool</span> occupied; <span class="hljs-comment">//是否被占用</span><br>    <span class="hljs-type">uint16_t</span> space_used; <span class="hljs-comment">//已被写入的数据长度</span><br>    <span class="hljs-type">uint32_t</span> number; <span class="hljs-comment">//块号</span><br>    <span class="hljs-type">uint32_t</span> inode_number; <span class="hljs-comment">//被索引的inode号</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 数据块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_block_t</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_info_t</span> <span class="hljs-title">info</span>;</span> <span class="hljs-comment">//元数据</span><br>    <span class="hljs-type">byte_t</span> data[DATA_BLOCK_SIZE]; <span class="hljs-comment">//实际数据</span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *文件表项</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir_entry_t</span> &#123;</span><br>    <span class="hljs-type">char</span> dir_name[<span class="hljs-number">124</span>]; <span class="hljs-comment">//文件名字</span><br>    <span class="hljs-type">uint32_t</span> inode_number; <span class="hljs-comment">//inode节点号</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *文件类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FILETYPE</span> &#123;</span><br>    None = <span class="hljs-string">&#x27;?&#x27;</span>,<br>    Normal = <span class="hljs-string">&#x27;-&#x27;</span>,<br>    Dir = <span class="hljs-string">&#x27;d&#x27;</span>,<br>    Charctor = <span class="hljs-string">&#x27;c&#x27;</span>,<br>    Block = <span class="hljs-string">&#x27;b&#x27;</span>,<br>    Socket = <span class="hljs-string">&#x27;s&#x27;</span>,<br>    Pipe = <span class="hljs-string">&#x27;p&#x27;</span>,<br>    Link = <span class="hljs-string">&#x27;l&#x27;</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *文件模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_mode_t</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FILETYPE</span> <span class="hljs-title">file_type</span>;</span> <span class="hljs-comment">//文件类型</span><br>    <span class="hljs-type">byte_t</span> up: <span class="hljs-number">3</span>; <span class="hljs-comment">//用户权限</span><br>    <span class="hljs-type">byte_t</span> gp: <span class="hljs-number">3</span>; <span class="hljs-comment">//组权限</span><br>    <span class="hljs-type">byte_t</span> ap: <span class="hljs-number">3</span>; <span class="hljs-comment">//其他人的权限</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *inode数据结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_t</span> &#123;</span><br>    <span class="hljs-type">bool</span> occupied; <span class="hljs-comment">//是否被占用</span><br>    <span class="hljs-type">uint32_t</span> number; <span class="hljs-comment">//节点号</span><br>    <span class="hljs-type">uint32_t</span> file_size; <span class="hljs-comment">//文件大小</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_mode_t</span> <span class="hljs-title">mode</span>;</span> <span class="hljs-comment">//文件模式</span><br>    <span class="hljs-type">int8_t</span> uid; <span class="hljs-comment">//用户id</span><br>    <span class="hljs-type">int8_t</span> gid; <span class="hljs-comment">//组id</span><br>    <span class="hljs-type">time_t</span> c_time; <span class="hljs-comment">//创建时间</span><br>    <span class="hljs-type">time_t</span> m_time; <span class="hljs-comment">//修改时间</span><br>    <span class="hljs-type">time_t</span> a_time; <span class="hljs-comment">//访问时间</span><br>    <span class="hljs-type">uint8_t</span> links; <span class="hljs-comment">//链接数</span><br>    <span class="hljs-type">inode_pointer_t</span> direct[INODE_DIRECT_NUM]; <span class="hljs-comment">//直接索引</span><br>    <span class="hljs-type">uint32_t</span> block_used; <span class="hljs-comment">//引用的数据块数量</span><br>    <span class="hljs-type">uint16_t</span> cnt_file_num; <span class="hljs-comment">//(当前目录下的文件数量，仅目录类型有效)</span><br>    <span class="hljs-type">inode_pointer_t</span> singly; <span class="hljs-comment">//一级索引</span><br>    <span class="hljs-type">inode_pointer_t</span> doubly; <span class="hljs-comment">//二级索引</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *磁盘数据结构(和本地存储的二进制结构不一样)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk_t</span> &#123;</span><br>    <span class="hljs-type">super_block_t</span> sb; <span class="hljs-comment">//超级块</span><br>    <span class="hljs-type">inode_t</span> *inode_list; <span class="hljs-comment">//inod节点表</span><br>    <span class="hljs-type">data_block_t</span> *data_block_list; <span class="hljs-comment">//数据块表(包括元数据和实际内容)</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>trapdoor 设计思路</title>
    <link href="/posts/a7b9/"/>
    <url>/posts/a7b9/</url>
    
    <content type="html"><![CDATA[<h1 id="原理和设计"><a href="#原理和设计" class="headerlink" title="原理和设计"></a>原理和设计</h1><p>本插件并没有用到什么十分高深的技巧或者技术，完全是在巨人的肩膀上进行的一些微小的工作，<br>毕竟tr最初的名字就叫<code>MCBEToolSet</code>.下面简单介绍下tr的原理和设计。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="HOOK和CALL"><a href="#HOOK和CALL" class="headerlink" title="HOOK和CALL"></a>HOOK和CALL</h3><p>Tr的核心就是基于Win32的hook技术,这也是它不能跨平台的最本质原因(linux上也有相应的技术，只不过没有采用)。</p><p>整个BDS的运行是就是各种函数依次执行的结果(其它软件也是)，不难想到，只要我们可以改动部分函数的逻辑就能在宏观上<br>影响玩家，这就是tr的核心原理。</p><p>hook技术给我们带来了下面两个核心的接口：</p><ol><li>HOOK</li><li>CALL</li></ol><p>HOOK就是能监听特定函数的执行，能让开发者在某个函数执行前和执行后插入部分代码，以及禁止某个函数的执行，下面是表示hook<br>接口的伪代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">hook</span>(function,before,after,execute):<br>    <span class="hljs-built_in">before</span>()<br>    if execute:<br>     <span class="hljs-built_in">function</span>()<br>    <span class="hljs-built_in">after</span>()<br></code></pre></td></tr></table></figure><p>function就是你要监听的函数，before和after就是运行前后要执行的回调代码，而execute就代表是否要执行该函数。<br>举个简单的例子，我在before里面获取当前时间，然后在after里面获取当前时间，然后将两个时间相减就获得了function()的执行时间，<br>这就是<code>mspt</code>和<code>prof</code>的基本原理。</p><p>CALL给开发者提供了手动调用某个函数的能力，下面是该接口的伪代码:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">def call(function,args):<br>    function(args)<br></code></pre></td></tr></table></figure><p>举个例子就是获取玩家坐标，可以手动调用<code>Actor::getPos(Player*)</code>这个函数即可.</p><h3 id="RVA及其计算"><a href="#RVA及其计算" class="headerlink" title="RVA及其计算"></a>RVA及其计算</h3><h4 id="RVA"><a href="#RVA" class="headerlink" title="RVA"></a>RVA</h4><p>知道最基本的原理后另一个问题来了，我们该如何在工程中实现上述想法呢？这个不用担心，前人早就提供了造好的轮子，能让开发者较为方便地对某个函数进行HOOK和CALL. Tr采用了目前BDS插件圈最常见的方案，也就是微软的<a href="https://github.com/microsoft/Detours">Detours</a>库,<code>api/lib/mod.h</code>里面的<code>THOOK</code>和<code>SYMCALL</code>宏就是对该库的简单封装。</p><p>下面要解决的问题就是如何确定要hook的函数原型(包括参数列表和返回值等)和其在内存中的地址。<br>前者可以通过开发者手动指定，这也是上面两个宏需要传原型的原因。后者就需要一定的计算了。这里涉及<br>的底层知识比较多就简单说几句。</p><p>我们可以简单地把(经过分页处理后的虚拟)内存理解成一个简单的街道，进程就是街道中的房子，而函数就是房子内的某个家具，编译软件就是造房子的过程。由于CPU在运行软件的时候需要知道每个函数的具体位置，因此编译软件的时候就要确定每个函数的地址(也就是家具相对于街道的位置信息)， 但是编译器并不知道操作系统会把进程放在哪个地址，因此编译期间传入的地址都是相对房子角落的，等CPU访问该地址的时候 就把这个相对房子角落的地址加上房子在街道的位置就构成了绝对地址，这样才能正常访问。</p><p>在上面的比喻中，家具相对房子的地址(也就是进程空间的地址)就是所谓的RVA(相对虚拟地址)，这个地址是能在编译期确定的。不仅如此，Win32的API还提供了获取房子相对街道地址的函数，也就是<code>GetModuleHandle</code>函数。<code>api/lib/mod.h</code>中的<code>getVA()</code>函数就执行了这个地址相加的过程。</p><h4 id="获取RVA"><a href="#获取RVA" class="headerlink" title="获取RVA"></a>获取RVA</h4><p>让我们继续往下，来看这个RVA如何获取。既然RVA是编译器确定的，那么想获取RVA就只能问编译器了。很巧的是编译器确实提供了这个功能。以MSVC为例，在特定的编译选项下，MSVC编译完成的时候会生成一个<code>pdb</code>格式的二进制附加文件，这个文件提供了该软件所有函数的RVA信息，而BDS的win版release中确实包含了一个<code>pdb</code>文件。</p><p>不仅如此，微软还提供了读取这个<code>pdb</code>文件的工具<code>cvdump</code>，我们可以执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cvdump -headers -p bdrock_server.exe &gt; dump_sym.txt<br></code></pre></td></tr></table></figure><p>打开<code>dump_sym.txt</code>文件你就能看到这样一个文件：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Microsoft (R) Debugging Information Dumper  Version <span class="hljs-number">14.00</span><span class="hljs-number">.23611</span><br>Copyright (C) Microsoft Corporation.  <span class="hljs-built_in">All</span> rights reserved.<br>*** PUBLICS<br>...<br>S_PUB32: [<span class="hljs-number">0001</span>:<span class="hljs-number">0079</span>ACB0], Flags: <span class="hljs-number">00000002</span>, ?tick@ServerLevel@@UEAAXXZ<br>...<br>*** SECTION HEADERS<br><br><br>SECTION HEADER #<span class="hljs-number">1</span><br>   .text <span class="hljs-keyword">name</span><br> <span class="hljs-number">1</span>A1C3EC virtual <span class="hljs-built_in">size</span><br>    <span class="hljs-number">1000</span> virtual address<br> <span class="hljs-number">1</span>A1C400 <span class="hljs-built_in">size</span> of raw <span class="hljs-keyword">data</span><br>     <span class="hljs-number">400</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">pointer</span> to raw <span class="hljs-keyword">data</span><br>       <span class="hljs-number">0</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">pointer</span> to relocation table<br>       <span class="hljs-number">0</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">pointer</span> to line numbers<br>       <span class="hljs-number">0</span> <span class="hljs-keyword">number</span> of relocations<br>       <span class="hljs-number">0</span> <span class="hljs-keyword">number</span> of line numbers<br><span class="hljs-number">60000020</span> flags<br>         Code<br>         (no align specified)<br>         Execute Read<br></code></pre></td></tr></table></figure><p>其中<code>*** PUBLICS</code>和<code>*** SECTION HEADERS</code>之间的每一行就是编译器提供给我们的一个函数的信息，我们以</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">S_PUB32: [<span class="hljs-number">0001</span>:<span class="hljs-number">00452070</span>], Flags: <span class="hljs-number">00000002</span>, ?<span class="hljs-symbol">tick@</span><span class="hljs-symbol">ServerLevel@</span><span class="hljs-meta">@UEAAXXZ</span><br></code></pre></td></tr></table></figure><p>为例看下这行，<code>0001</code>是段号，表示该函数属于哪个段（段相当于房子内的某个区域），<code>0079ACB0</code>是段内地址，<code>?tick@ServerLevel@@UEAAXXZ</code>就是所谓的符号，这个字符串包含了该函数的原型信息。为了计算RVA,我们需要知道该函数所属段的首地址。下面再来看<code>*** SECTION HEADERS</code>下面的部分，不难发现这里正好就是段信息，<code>1000 virtual address</code>给出了该段的相对地址就是1000。综上所述，函数<code>?tick@ServerLevel@@UEAAXXZ</code>的RVA就是0x0079ACB0+0x1000 &#x3D; 0x0079BCB0.</p><p><code>api/lib/SymHook.h</code>中的地址都是这么算出来的。由于手工计算过于麻烦，所以社区就诞生了一些工具来自动执行这个计算和导出RVA的过程，这也是一般情况下Tr更新的主要成本。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>Tr源码结构如下所示:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">├───api <span class="hljs-regexp">//</span>游戏接口<br>│   ├───block <span class="hljs-regexp">//</span>方块接口<br>│   ├───commands <span class="hljs-regexp">//</span>命令注册和解析<br>│   ├───entity <span class="hljs-regexp">//</span>实体接口<br>│   ├───graphics <span class="hljs-regexp">//</span>粒子效果接口<br>│   ├───language <span class="hljs-regexp">//</span>多语言支持<br>│   ├───lib <span class="hljs-regexp">//</span>hook库和其它第三方库<br>│   ├───tools <span class="hljs-regexp">//</span>工具,包括日志,向游戏内部发信息,简单的线程池实现等等<br>│   └───world <span class="hljs-regexp">//</span>Level,Dimension接口<br>├───mod  <span class="hljs-regexp">//</span>具体的功能<br>│   ├───config <span class="hljs-regexp">//</span>配置文件<br>│   ├───eval <span class="hljs-regexp">//</span>计算器功能<br>│   ├───fakePlayer <span class="hljs-regexp">//</span>假人通信功能<br>│   ├───<span class="hljs-keyword">function</span> <span class="hljs-regexp">//</span>漏斗计数器,转方块等功能<br>│   ├───os <span class="hljs-regexp">//</span>os相关功能<br>│   ├───player <span class="hljs-regexp">//</span>玩家相关功能<br>│   ├───spawn <span class="hljs-regexp">//</span>刷怪相关功能<br>│   ├───test <span class="hljs-regexp">//</span>一些不太全面的测试<br>│   ├───tick <span class="hljs-regexp">//</span>tick和prof的实现<br>    └───village <span class="hljs-regexp">//</span>村庄相关功能<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言的一些关键字(C语言复习一)</title>
    <link href="/posts/4dc8/"/>
    <url>/posts/4dc8/</url>
    
    <content type="html"><![CDATA[<p>没办法,考研复试要考笔试C语言，这里只能简单复习下了，这篇主要是说下关键字<code>auto static extern register</code>的用法</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><code>static</code>主要有如下三个用法</p><ul><li>在函数内部修饰一个变量</li><li>在.c文件中限制函数的作用域</li><li>在数组参数中限制数组的最小长度</li></ul><h3 id="函数内部修饰变量"><a href="#函数内部修饰变量" class="headerlink" title="函数内部修饰变量"></a>函数内部修饰变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    i++;<br> j++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d j = %d\n&quot;</span>, i,j);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码执行后，i的输出从1依次递增到10，而j永远都是1</p><blockquote><p>这个用法在c++中也能用，可以用来维护一些全局变量</p></blockquote><h3 id="在-c文件中限制作用域"><a href="#在-c文件中限制作用域" class="headerlink" title="在.c文件中限制作用域"></a>在<code>.c</code>文件中限制作用域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//a.h</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">///a.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">helperFunction</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>   helperFunction();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>helperFunction</code>在其它文件中是不可用的，只有在<code>a.c</code>中才能使用</p><blockquote><p>这个用法在C++中也能用，把函数可见性限制在编译单元内，但是C++更推荐直接使用<code>namespace&#123;&#125;</code></p></blockquote><h3 id="在数组参数中限制最小长度"><a href="#在数组参数中限制最小长度" class="headerlink" title="在数组参数中限制最小长度"></a>在数组参数中限制最小长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">printVec3</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[<span class="hljs-type">static</span> <span class="hljs-number">3</span>])</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述参数中限制了<code>arr</code>的长度必须大于等于3</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>现在C语言中的<code>auto</code>没啥屌用</p><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">It<span class="hljs-comment">&#x27;s a hint to the compiler that the variable will be heavily used and that you recommend it be kept in a processor register if possible.</span><br><br>Most modern compilers <span class="hljs-keyword">do</span> that automatically, <span class="hljs-built_in">and</span> are better at picking them than us humans.<br></code></pre></td></tr></table></figure><p><code>register</code>是一个编译提示，提示这个变量很常用，让编译器把这个变量丢CPU的寄存器上以提高读写速度，这个优化在现代编译器中是自动完成的，因此也不用管</p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a><code>extern</code></h2><p>这个关键字是用来声明全局变量的，也就是访问跨编译单元的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//a.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a; <span class="hljs-comment">//声明</span><br><br><span class="hljs-comment">//a.c</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">//定义</span><br><br><span class="hljs-comment">//main.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上图，在<code>.h</code>中用<code>extern</code>声明，在<code>.c</code>中定义，然后包含对应的<code>.h</code>文件就能直接访问了</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象1</title>
    <link href="/posts/1ce9/"/>
    <url>/posts/1ce9/</url>
    
    <content type="html"><![CDATA[<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p>要解释什么是类,什么是对象还真实很麻烦的事情,但我尽量吧.</p><p>传统的面向过程编程是一步一步地按照顺序执行的。比如说我要计算一个班10个学生的平均成绩，我会先把这10个数据准备好，然后再求和，最后把和再除以10 ，这样一步一步地把结果算出来。这就是所谓的面向过程的编程。</p><p>而面向对象却不一样，程序要操作的是对象(Object).还是刚刚那个程序，从面向对象的角度来说我们要做的是计算<strong>学生</strong>的平均成绩，重心再对学生进行一些操作。而不是计算这一行为。</p><p>那么，何为对象？该怎么描述对象？对象就是实体。在很多情况下，要精准地描述一个对象是很困难的，但是也没有这个需要。在C++的面向对象中，我们要做的仅仅是通过描述对象的一些属性来确定一个对象。</p><p>比如学生对象，在刚刚的例子中，我们不需要关注学生的名字，性别，因为这对解决问题并没有任何帮助，因此在这个例子中用成绩这一属性来描述学生对象就足以。</p><p>下面的例子就是对学生对象的一个描述或者叫约束，它规定了学生这个实体有一个<code>score</code>属性而且这个<code>score</code>属性是<code>int</code>类型的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>&#123;<br><span class="hljs-type">int</span> score;<span class="hljs-comment">//score</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>再比如我要描述一个老师对象，需要用到老师的名字，年纪，性别，就可以这样描述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>&#123;<br>std::string name;<br>    std::string gender;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="C-中的类"><a href="#C-中的类" class="headerlink" title="C++中的类"></a>C++中的类</h2><p>上面的对象描述信息就叫做<code>类</code>。</p><ul><li><p>类不是对象，只是对对象的属性的一种描述，一种约束</p></li><li><p>类可以用来生产对象</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">bool</span> c;<br>&#125;;<span class="hljs-comment">//创建一个类</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<span class="hljs-comment">//由这个类生产一个叫a的对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>举这样一个例子，在浇筑工件的时候我们需要模具来使工件成为我们需要的模样。C++中类的建立和对象的创建也是如此，<code>class&#123;...&#125;;</code>建立了一个叫A的模具,(那模具是不是对象呢：）)，<code>A a;</code>相当于浇筑过程，通过模具A产生了一个叫<code>a</code>的对象。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>当然我们对对象的，描述不只是有属性，还可以有行为，把对对象的行为描述称为<code>方法</code>,或者叫成员函数?</p><p>在类中可以这样定义方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getA</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> a;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getB</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> b;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getA()</code>和<code>getB()</code>就是对A类对象的方法的描述。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/posts/8a9d/"/>
    <url>/posts/8a9d/</url>
    
    <content type="html"><![CDATA[<p>寒假在家基本看完了谢希仁的《计算机网络》，其中最重要的四五两章感觉看的不明不白的，这里特地做个总结。</p><span id="more"></span><ul><li>IP数据报 分组等词在这里同义</li></ul><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><h3 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h3><p>网络层采用的设计思路:</p><ul><li><strong>网络层只提供简单灵活的，无连接的尽最大努力交付的数据报服务</strong></li><li>网络层是<strong>面向无连接</strong>的，不提供服务质量的承诺，数据的可靠性由用户主机来保证</li></ul><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><p>另外三个配套使用的协议：</p><ul><li><p>地址解析协议ARP</p></li><li><p>网际控制·报文协议ICMP</p></li><li><p>网际组管理协议IGMP</p></li></ul><h4 id="虚拟互联网络"><a href="#虚拟互联网络" class="headerlink" title="虚拟互联网络"></a>虚拟互联网络</h4><p>四种中间设备：</p><ul><li>转发器–物理层使用</li><li>网关–网络层以上使用</li><li>网桥–数据链路层使用（两个网络合成一个新的网络（并不是互联网））</li><li>路由器（网络层使用，把多个网络连接形成互联网）</li></ul><p><strong>能用路由器连接起来的互联网都使用了相同的网际协议IP（Internet protocol）</strong></p><p>可以将互联之后的网络称之为虚拟互联网络（internet）,在某些层面上统一了不同的网络，互联网可以由多种异构的网络互相连接而成（统一它们的正是网际协议IP）</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>定义：（第四代，即IPv4）IP地址就是给互联网上的每一台主机（或者路由器）的<strong>每一个接口</strong>分配一个在全世界范围内唯一的32位标识符。<strong>路由器因为有多个端口因此有多个IP地址</strong></p><p>IP地址的编址方法分为以下三个阶段：</p><ul><li>分类的IP地址</li><li>子网的划分</li><li>构成超网</li></ul><h5 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h5><p>IP地址分为ABCDE共五类</p><p>ABC类由两个固定长度的字段构成：</p><ul><li><p>第一个字段是网络号（net-id）,用来<strong>标志主机（或者路由器）所连接到的网络</strong></p></li><li><p>第二个是主机号（host-id），用来<strong>标志主机（或路由器）</strong></p></li></ul><p>综上，IP地址可以标志某个特定的端口是哪个网络上的哪个主机：</p><p><strong>IP地址::&#x3D;{网络号，主机号}</strong></p><table><thead><tr><th>IP类别</th><th>网络号位数</th><th>主机号位数</th><th>备注</th></tr></thead><tbody><tr><td>A</td><td>8</td><td>24</td><td>单播地址（一对一通信）</td></tr><tr><td>B</td><td>16</td><td>16</td><td>单播地址</td></tr><tr><td>C</td><td>24</td><td>8</td><td>单播地址</td></tr><tr><td>D</td><td>–</td><td>–</td><td>多播地址</td></tr><tr><td>E</td><td>–</td><td>–</td><td>备用</td></tr></tbody></table><p>IP地址常用<strong>点分十进制法</strong>来表示，如127.0.0.1</p><p>IP地址的指派范围：</p><table><thead><tr><th>网络类别</th><th>最大可指派数</th><th>可指派的网络号</th><th>每个网络中的最大主机数</th></tr></thead><tbody><tr><td>A</td><td>2^7-2</td><td>1–126</td><td>16777214</td></tr><tr><td>B</td><td>2^14-1</td><td>128.1–191.255</td><td>65534</td></tr><tr><td>C</td><td>2^21-1</td><td>192.0.1–255.255.255</td><td>254</td></tr></tbody></table><p>IP地址的重要特点：</p><ul><li>每一个IP地址都由网络号和主机号构成：<ul><li>IP地址管理机构只分配网络号，便于管理</li><li>路由器只根据网络号来转发分组（目的地址不是本网络的时候只用管网络号而不用管具体端口号），减小了路由表的存储空间和减少了查找时间</li></ul></li><li>实际上的IP地址是标志一台主机和一条链路的接口，具有多个端口的主机也有多个IP地址，称为<strong>多归属主机</strong>，最典型的例子是<strong>路由器</strong></li><li>所有的网络都是都是平等的</li></ul><h4 id="IP地址和硬件地址"><a href="#IP地址和硬件地址" class="headerlink" title="IP地址和硬件地址"></a>IP地址和硬件地址</h4><ul><li>物理地址是数据链路层和物理层用的地址</li><li>IP地址是网络层级以上层用的地址</li></ul><p>包含了IP地址的IP数据报是数据链路层的数据报的数据部分，数据链路层看不见IP数据报的IP地址</p><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>ARP协议的作用：从网络层使用的<strong>IP地址</strong>解析出数据链路层使用的<strong>硬件地址</strong></p><p>主机（或者路由器）中的IP地址和MAC地址没有绝对地一一对应关系，并且这个关系可能是动态更新的。每一台主机都有一个ARP cache ,里面有<strong>本局域网</strong>上的各个主机和路由器的IP地址到硬件地址的映射关系。把IP协议封装成MAC帧的时候需要使用该协议。 </p><h4 id="IP数据报的构成"><a href="#IP数据报的构成" class="headerlink" title="IP数据报的构成"></a>IP数据报的构成</h4><ul><li><p>版本号 4位</p></li><li><p>首部长度 4位</p></li><li><p>区分服务 8位，一般情况下用不到</p></li><li><p>总长度 16位  总长度 &#x3D; 首部 + 数据长度</p></li><li><p>标识 16位 分片的数据报组装的序号</p></li><li><p>标志 3位 用来标记前后是否还有分片</p></li><li><p>片偏移 13位 表示某片在整个分片后的数据报的相对位置</p></li><li><p>生存时间 8位 表示数据报在网络中的寿命（TTL）(早期以S作为单位，现在以跳转次数作为单位)</p></li><li><p>协议 8位 指明数据报中的数据使用何种协议</p></li><li><p>首部检验和 对数据报的首部进行检验</p></li><li><p>源地址</p></li><li><p>目的地址</p></li></ul><h3 id="网络层的两个核心问题"><a href="#网络层的两个核心问题" class="headerlink" title="网络层的两个核心问题"></a>网络层的两个核心问题</h3><ul><li>如进行分组转发</li><li>如果更新和维护路由器的路由表<blockquote><p>下面是针对第一个问题的讨论：</p></blockquote></li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>最本质的变化：从两级IP地址（{网络.主机}）–&gt;三级网络地址（{网络.子网.主机}）</p><p>子网划分的基本思路：</p><ul><li>单位可将所属的网络划分为若干个子网，这些子网对外仍未一个网络</li><li><strong>IP地址::&#x3D;{网络号，子网号，主机号}</strong></li></ul><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网的划分对外部网络不可见</p><p>因此从IP数据报无法看出源主机是否进行了子网的划分</p><p><strong>网络地址 &#x3D; IP and 子网掩码</strong></p><p>路由器在和相邻网络之间交换路由信息的时候必须<strong>把自己自己所在网络（或子网）的子网掩码告诉相邻路由器</strong></p><p>在路由器路由表中的每一个项目，除了要给出目的的网络地址，也要给出该网络地址的子网掩码</p><h3 id="使用子网时候的分组转发过程"><a href="#使用子网时候的分组转发过程" class="headerlink" title="使用子网时候的分组转发过程"></a>使用子网时候的分组转发过程</h3><ol><li>从收到的数据报的首部提取目的IP地址D</li><li>先判断是否为直接交付。对和本路由器直接相连的网络逐个进行检查，用各网络的子网掩码和D进行AND操作，如果匹配就直接交付，不匹配就是间接交付，执行3</li><li>若路由表中有目的地址为D的特定主机路由，则根据该特定路由进行交付，否则执行4</li><li>对路由表中的每一行，用其中的子网掩码和D逐位与操作，若其结果N与该行的目的网络地址匹配，则根据该路由进行交付，否则执行5</li><li>若路由表中有默认路由，贼按照默认路由2交付，否则报告分组转发出错</li></ol><h2 id="CIDR-构造超网"><a href="#CIDR-构造超网" class="headerlink" title="CIDR 构造超网"></a>CIDR 构造超网</h2><p>CIDR的主要特点：</p><ul><li><p>消除了传统的A，B，C类地址和划分子网的概念，CIDR使得IP地址从三级编程无分类的两级IP地址：</p><p><strong>IP地址::&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;}</strong></p></li><li><p>CIDR把网络前缀相同的连续IP地址组成一个CIDR地址块</p></li></ul><p>a.b.c.d&#x2F;n表示IP a.b.c.d中前n位是网络前缀，后32-n位是主机号</p><h3 id="网络掩码"><a href="#网络掩码" class="headerlink" title="网络掩码"></a>网络掩码</h3><p>a.b.c.d&#x2F;n的网络掩码前n位是1，后32-n位是0</p><h3 id="超网的分组转发"><a href="#超网的分组转发" class="headerlink" title="超网的分组转发"></a>超网的分组转发</h3><p>CIDR的分组转发过程和之前的并没有什么不同，只不过由于CIDR的特殊性，在进行掩码计算以匹配网络的时候要<strong>优先匹配最长前缀</strong></p><blockquote><p>下面是针对第二个问题：路由表维护 的讨论</p></blockquote><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="有关路由选择协议的几个基本概念"><a href="#有关路由选择协议的几个基本概念" class="headerlink" title="有关路由选择协议的几个基本概念"></a>有关路由选择协议的几个基本概念</h3><p>路由选择算法的特点：</p><ul><li>算法必须是正确的和完整的</li><li>算法在计算上应简单</li><li>算法应能适应通信量和网络拓扑的变化</li><li>具有稳定性</li><li>具有公平性</li></ul><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><p>互联网被分为多个较小的<strong>自治系统</strong>（autonomous system，AS），AS内部使用的路由选择协议称为<strong>内部网关协议(IGP)<strong>，如RIP和OSPF，AS之间的路由选择协议称为</strong>外部网关协议（EGP）</strong>,如BGP-4</p><h4 id="内部网关协议RIP和OSPF"><a href="#内部网关协议RIP和OSPF" class="headerlink" title="内部网关协议RIP和OSPF"></a>内部网关协议RIP和OSPF</h4><table><thead><tr><th>属性</th><th>RIP</th><th>OSPF</th></tr></thead><tbody><tr><td>base</td><td>距离向量</td><td>链路状态</td></tr><tr><td>算法</td><td>Ford</td><td>Dijkstra</td></tr><tr><td>效率</td><td>较低</td><td>较高</td></tr><tr><td>内存占用</td><td>较小</td><td>较大</td></tr><tr><td>适用范围</td><td>较小的网络</td><td>较大的网络</td></tr><tr><td>传送方式</td><td>UDP</td><td>IP数据报</td></tr></tbody></table><h4 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h4><p>略.</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从零开始搭建java ssm项目</title>
    <link href="/posts/324f/"/>
    <url>/posts/324f/</url>
    
    <content type="html"><![CDATA[<h2 id="用IDEA来进行完整的ssm项目配置（多图）"><a href="#用IDEA来进行完整的ssm项目配置（多图）" class="headerlink" title="用IDEA来进行完整的ssm项目配置（多图）"></a>用IDEA来进行完整的ssm项目配置（多图）</h2><p>1.选择<code>create new project--&gt;maven</code>,把上面方的<code>Crteate from archetype</code>勾上后在列表选择<code>org.apache.maven.archetypes:maven-archetype-webapp</code>,然后点<code>next</code></p><p><img src="http://ws4.sinaimg.cn/large/007bwgzIly1fx1x3u4rt1j30wv0qy417.jpg" alt="image"></p><p>2填上包名和artifactId名字（随便取），点<code>next</code></p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xbbvqd9j30wv0qyjrt.jpg" alt="image"></p><p>3.自行选择是否更改maven的本地仓库路径和配置文件路径（这里是默认的，没改），点<code>finish</code></p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1xhb0eruj30wv0qyjs1.jpg" alt="image"></p><p>4.上一步点了<code>next</code>后就到了主界面，这里IDEA会自动配置项目的artifact,左下角会出现一个弹窗，点<code>inport changes</code></p><p><img src="http://ws4.sinaimg.cn/large/007bwgzIly1fx1xf0l0p9j31hc0tj0x9.jpg" alt="image"></p><p>5,此时的项目结构应该是这样的：</p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1xiwjcn1j30di0cvmxg.jpg" alt="image"></p><p>6，在<code>main</code>下新建<code>java</code>和<code>resources</code>文件夹</p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1xl3abx3j30dp0fzdg7.jpg" alt="image"></p><p>7.右键刚刚创建的<code>java</code>文件夹，选择<code>make dictionary as-&gt;Sources root</code>，同样地，对刚刚创建的<code>resources</code>文件夹选择<code>make dictionary as-&gt; resources root</code></p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1xlsehrcj30id0pyq59.jpg" alt="image"></p><p>7.在<code>java</code>目录下创建相应的包，在<code>resources</code>目录下创建<code>config,mapper</code>文件夹，<code>webapp</code>下创建静态资源文件夹，<code>WEB-INF</code>下创建<code>jsp</code>文件夹，全部完成后的目录应该是这样的：</p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xr2favmj30750eljre.jpg" alt="image"></p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1xrbvrs4j30820akjrd.jpg" alt="image"></p><p>可以看到对于不同的文件夹idea会给不同的图表，这也是IDEA的智能之处之一。</p><p>8 配置<code>pox.xml</code>添加相应的依赖，<code>&lt;dependency&gt;</code>内容如下(可以根据自己需要进行增减)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jspapi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.public_draft<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>servletapi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4-20040521<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aopalliance<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aopalliance<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>20041228.180559<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.12.1.GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>9.接下来IDEA会自动更新项目依赖（取决于网速），右下角会有一个叫你更新配置的弹窗，点<code>import changes</code>即可，完后工程目录下的<code>external libeary</code>下会出现刚刚添加的依赖：</p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xxfm9yuj30fn04ajra.jpg" alt="image"></p><p><img src="http://ws2.sinaimg.cn/large/007bwgzIly1fx1xykq0pmj30dt0kq3zd.jpg" alt="image"></p><p>10.在<code>resources/config</code>下创建<code>applicationContext.xml</code><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1xzjj40cj315z0qtadh.jpg" alt="image"></p><p>创建好的<code>applicationContext.xml</code>是这样的，点左上角的<code>configapplication context</code> </p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1y2nav1sj311z0a2750.jpg" alt="image"></p><p>点<code>create new application context</code>弹出窗口后选OK</p><p><img src="http://wx1.sinaimg.cn/large/007bwgzIly1fx1y3l5po9j30a603ja9y.jpg" alt="image"></p><p><img src="http://ws2.sinaimg.cn/large/007bwgzIly1fx1y4p7z2aj30lj0rmdg7.jpg" alt="image"></p><p>11.用和第10步一模一样的方法在<code>resources/config</code>下创建<code>springmvc.xml</code></p><p><img src="http://wx2.sinaimg.cn/large/007bwgzIly1fx1y6cgdclj30ci04t745.jpg" alt="image"></p><p>12.在<code>resources/config</code>下创建<code>mybatis-config.xml</code>，也就是mybatis的配置文件</p><p><img src="http://wx3.sinaimg.cn/large/007bwgzIly1fx1y9m2z95j30lm0ab3zb.jpg" alt="image"></p><p><img src="http://ws3.sinaimg.cn/large/007bwgzIly1fx1y8lmeh3j30ci04tq2t.jpg" alt="image"></p><p>13.用和12一样的方法创建<code>log4j.properties</code>和<code>db.properties</code>，完成后<code>resources</code>的目录如下：</p><p><img src="http://ws1.sinaimg.cn/large/007bwgzIly1fx1ybkptysj309o07tjrd.jpg" alt="image"></p><p>14.至此，所有文件的创建完成，下面是<code>resources</code>目录下几个配置文件的内容：</p><p><code>db.properties</code>:配置数据库参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/boot_crm?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-attr">jdbc.maxTotal</span>=<span class="hljs-string">30</span><br><span class="hljs-attr">jdbc.maxIdle</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">jdbc.initalSize</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p><code>aplicationcontext.xml</code>：spring的核心配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:config/db.properties&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--配置配置文件的路径--&gt;</span><br>    <span class="hljs-comment">&lt;!--配置数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxTotal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.maxTotal&#125;&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--最大连接数--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.maxIdle&#125;&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--最大空闲数--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.initalSize&#125;&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--初始连接数--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置mybatis会话工厂--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:config/mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置mapper扫描器·--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.agno3.dao&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置Service扫描器--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.agno3&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>springmvc.xml</code>：spring的核心配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.agno3.controller&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--controller扫描器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br>    <span class="hljs-comment">&lt;!--静态资源访问映射 （不被拦截器拦截）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/js/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/js/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/css/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/css/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/images/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/images/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/fonts/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/fonts/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--配置视图解析器的前后缀--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>mybatis-config.xml</code>：mybatis的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里的培植信息不用了（在spring的培植文件里面）--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>15.最后就是在<code>web.xml</code>中配置全局拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">web-app</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br><br>  <span class="hljs-comment">&lt;!--配置Spring文件监听器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:/config/applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--spring-mvc 的拦截器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>spring-mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:config/springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>spring-mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--拦截所有请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>至此整个ssm框架就搭建完成了23333.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>带符号数表示</title>
    <link href="/posts/8556/"/>
    <url>/posts/8556/</url>
    
    <content type="html"><![CDATA[<p>最近在看有关数值的表示有关的知识，因为实在太过混乱，所以在这里总结一下，主要讲<strong>原码，反码和补码</strong>这三种表示带符号数的表示方法。</p><span id="more"></span><p>一直在纠结<code>-10010,+100011</code>这样的还没编码的带符号的二进制数字用什么名词来表示，这也是我一开始看这个的时候有点懵逼的主要原因。所以在这里先约定一下：</p><blockquote><p>用X表示<code>-100,+1111</code>这样的还没编码的带符号的二进制数，N表示X的位数，O(Original code)表示X的原码，用I(Inverse code)表示X的补码，用C(Complement code)表示X的补码。</p></blockquote><p>开始之前再来行几点说明：</p><ul><li><p>所以的示范都是一个字节(1Byte)的空间作为样本</p></li><li><p>所有的示意图均为Graphviz所实现</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>原码，反码和补码这三种编码方法有个共通之处就是这三种编码的<strong>最高位都表示它所代表的数的符号，0表示正数，1表示负数</strong>，其余位表示数的大小(绝对值)：</p><p><img src="http://wx1.sinaimg.cn/mw690/007bwgzIly1fvmzuhhthej308a04d0sk.jpg" alt="image"></p><p>也就是说，N位的X的三种编码值O,I,C都有N+1位, <strong>一个字节最多能表示7位的带符号二进制数</strong>.</p></li></ul><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码是最简单的表示法</p><ul><li><p>N位的X对应得原码有N+1位</p></li><li><p>最高位（也称符号位）是符号</p></li><li><p>其余N-1位（也称数值位）是x的绝对值</p></li></ul><p>下面有几个例子：</p><table><thead><tr><th align="center">X</th><th align="center">O</th></tr></thead><tbody><tr><td align="center">+10010</td><td align="center"><strong>0</strong> 10010</td></tr><tr><td align="center">-11100</td><td align="center"><strong>1</strong> 11100</td></tr><tr><td align="center">+100 1111</td><td align="center"><strong>0</strong> 100 1111</td></tr></tbody></table><p>在一个字节上X的分布是这样的：</p><p><img src="http://ws4.sinaimg.cn/mw690/007bwgzIly1fvn4yz4nwij30it04daa1.jpg" alt="image"></p><p>不难发现0有两个原码，<code>1000 0000</code>和<code>0000 0000</code>,这是编码的特殊性造成的</p><p>原码虽然表示直白，很好理解，但在运算的时候会带来不变。</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>对于正数，反码表示法和原码表示法是一样的，他们俩的主要区别是负数的数值位表示上：</p><ul><li><p>正数最高位时0，负数最高位是1</p></li><li><p>对于正数，其余N-1位是X的绝对值</p></li><li><p>对于负数，其余N-1位是X的绝对值再<strong>按位取反</strong></p></li></ul><p>下面是几个例子：</p><table><thead><tr><th align="center">X</th><th align="center">I</th></tr></thead><tbody><tr><td align="center">+10111</td><td align="center"><strong>1</strong> 10111</td></tr><tr><td align="center">+0</td><td align="center"><strong>0</strong> 000</td></tr><tr><td align="center">-100010</td><td align="center"><strong>1</strong>  <u>11101</u></td></tr><tr><td align="center">-0</td><td align="center"><strong>1</strong> <u>11111</u></td></tr></tbody></table><p>同样，下面是反码的分布图：</p><p><img src="http://ws4.sinaimg.cn/mw690/007bwgzIly1fvn5rzs903j30it04d3yh.jpg" alt="image"></p><p>可以看到，下方的+0…+127,-127,…-0,是完全大对称分布的，不难发现以下规律：</p><ul><li><p>同原码一样，0的反码也有两个，<code>0000 0000</code>和<code>1111 1111</code></p></li><li><p>求X的相反数X的反码只需将X的反码按位取反</p></li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>现在最常用的还是<strong>补码</strong>,这种最复杂的编码却凭着先天的优势成为三种编码中最常用的一种,补码对于正数的规则和反码，原码完全一样，这里主要说一下负数的反码表示</p><ul><li>负数的最高位还是1，后面N-1位是$2^{N-1}+X$的二进制表示</li></ul><p>下面有几个例子：<br>X &#x3D; -10010，$2^{7}+(-10010_{2}) &#x3D; ‭1101110_{2}​$ ,因此X的补码位<code>1 110 1110</code></p><p>下面还是给出它的分布图：<br><img src="http://ws1.sinaimg.cn/mw690/007bwgzIly1fvn68tew6ej30it04d3yh.jpg" alt="image"></p><p>最显著的特点就是<strong>0只有唯一的补码<code>0000 0000</code><strong>，不仅如此，</strong>负数补码就是在其反码的基础上再加一</strong>：</p><blockquote><p>若X &gt;0:<br>$$<br>X_{O} &#x3D; X_{I} &#x3D; X_{C}<br>$$<br>若X&lt;0<br>$$<br>X_{C} &#x3D; X_{I}+1<br>$$</p></blockquote><p>补码在计算上面有独特的优势：</p><blockquote><p>如果：<br>$$<br>A + B &#x3D; C<br>$$<br>那么有：<br>$$<br>A_{C} + B_{C} &#x3D; C_{C}<br>$$</p></blockquote><p>A,B,C是有符号数，I_A,是其对应的补码，然而这个结论在原码和反码上并不成立，这大概就是补码最成功的一点吧，但数据溢出问终究是存在的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Graphviz——用代码绘制你的结构图</title>
    <link href="/posts/f09c/"/>
    <url>/posts/f09c/</url>
    
    <content type="html"><![CDATA[<p>最近在看《大话数据结构》的时候一直不知道书上的那种图是咋画的:</p><p><img src="http://wx4.sinaimg.cn/mw690/007bwgzIly1fvgfft38eoj30ab06zglp.jpg" alt="image"></p><p>直到这两天才偶然发现这个软件<strong>Graphviz</strong>,下面一起来详细看看这个软件</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>下面是<a href="https://graphviz.gitlab.io/">官网</a>对graphviz的介绍：</p><blockquote><p>Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. Automatic graph drawing has many important applications in software engineering, database and web design, networking, and in visual interfaces for many other domains.</p><p>Graphviz is open source graph visualization software. It has several main graph layout programs. See the <a href="https://graphviz.gitlab.io/gallery">gallery</a> for some sample layouts. It also has web and interactive graphical interfaces, and auxiliary tools, libraries, and language bindings</p></blockquote><p>简单地说Graphviz(全称Graph visualization)是开源的专门用于绘制抽象的网络图，结构图的软件（或者是库），不仅如此，它还为提供了它的图形接口，给其他语言提供了相关库等，总而言之就是一个牛逼哄哄的图形库。</p><h2 id="画廊"><a href="#画廊" class="headerlink" title="画廊"></a>画廊</h2><p>下面是一些用graphviz画的图（来自官网）：</p><p><img src="https://wx4.sinaimg.cn/large/007bwgzIly1fvgfqic5uoj302z04ba9y.jpg"></p><p><img src="https://ws1.sinaimg.cn/large/007bwgzIly1fvgfrbgyeaj30d00hit9x.jpg"></p><p><img src="https://ws2.sinaimg.cn/large/007bwgzIly1fvgfszk6akj31mw1by4qp.jpg"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这一篇好水啊，自己对它的语法也没完全搞清楚，等我把英文文档看完了再来更新Graphviz的教程吧，博客为了这个软件特地开了一个分类。真的好喜欢这个软件233333,终于结束了用Ai,画图和powerPoint  来画图的日子。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>λ表达式</title>
    <link href="/posts/ebc9/"/>
    <url>/posts/ebc9/</url>
    
    <content type="html"><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h3 id="啥是匿名函数"><a href="#啥是匿名函数" class="headerlink" title="啥是匿名函数"></a>啥是匿名函数</h3><p>在写这篇文章之前我去查了一遍λ表达式，然后就发现了这个东西——匿名函数，至于为啥要说匿名函数，我们以后再说，下面是wiki对匿名函数的定义：</p><blockquote><p>在计算机编程中，匿名函数（英语：anonymous function）是指一类无需定义标识符（函数名）的函数或子程序，普遍存在于多种编程语言中。</p></blockquote><p>相信你们看完后对匿名函数有一个大概印象了。顾名思义，匿名函数就是没名字的函数，你可能会问，一个函数没名字我们咋知道它就是它，是的，我们当然不知道，但是这都建立在多次调用这个函数的前提下，如果一个函数我们只用一次就不需要它了，它还需要名字吗？类似下面的例子：这个异常我们仅仅抛出一次，它还需要名字吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br></code></pre></td></tr></table></figure><p>没错这里的<code>NullPointerException()</code>实例是没名字的，但这样很方便不是吗？<code>new NullPointerException()</code>就是一个匿名的对象，匿名函数也是一样的道理。</p><h2 id="匿名函数咋写"><a href="#匿名函数咋写" class="headerlink" title="匿名函数咋写"></a>匿名函数咋写</h2><p>知道匿名函数是啥后，匿名函数咋写呢（以java为例）？</p><p>先来看一个普通函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a*a;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b*b;<br>  <span class="hljs-keyword">return</span> x+y;<br>&#125;<br></code></pre></td></tr></table></figure><p>普通函数（方法）有以下几个部分：</p><ul><li>返回值类型</li><li>函数名</li><li>参数列表</li><li>函数体</li><li>返回值<br>再来看看这个函数转换成匿名函数后的样子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a*a;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b*b;<br>       <span class="hljs-keyword">return</span>  x+y;<br>   &#125;<br></code></pre></td></tr></table></figure>上面的普通函数和匿名函数的差别还是很明显的，和普通函数相比，匿名函数少了返回值类型，少了函数名，多了一个特殊的符号<code>-&gt;</code>，没错这就是匿名函数的一般写法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表)-&gt;&#123;执行逻辑&#125;<br>()-&gt;&#123;执行逻辑&#125;<span class="hljs-comment">//没返参数的时候前面的括号不能省略</span><br></code></pre></td></tr></table></figure>当然如果执行逻辑只有一行的话可以省去大括号，<code>-&gt;</code>后面只写返回值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; a*b+b*b<br></code></pre></td></tr></table></figure></li></ul><p>下面还有几个常见的匿名函数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(String s)-&gt;System.out.print(s)<br>(a,b,c)-&gt;a+b+C <span class="hljs-comment">//有的时候传入参数列表也可以省</span><br>a-&gt;a*a <span class="hljs-comment">//一个参数可以省略括号</span><br></code></pre></td></tr></table></figure><p>叨叨完匿名函数可以告诉你们了，<strong>匿名函数就是λ表达式</strong>。</p><h2 id="java中的λ表达式"><a href="#java中的λ表达式" class="headerlink" title="java中的λ表达式"></a>java中的λ表达式</h2><p>下面的内容主要是对《java 和谐技术I》一书中λ表达式部分的总结</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>java中的某些接口仅仅由一个抽象方法构成，比如线程中常用的<code>Runnable</code>接口里面只有一个抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一目的就是给Thread类来实现，以定义线程在运行过程中的具体实现（也就是<code>run()</code>方法）。下面是一个线程的创建，实现的<code>run()</code>方法就是线程启动时候执行的动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello java&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>为了定义线程的动作又是传入接口，又是实现抽象函数，这样是不是麻烦了一点，能不能直接把<code>run()</code>里面的代码块也就是”动作“当参数传如呢？答案当然是肯定的，这就要借助λ表达式的力量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> ()-&gt;System.out.println(<span class="hljs-string">&quot;hello java&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br></code></pre></td></tr></table></figure><p>这样是不是方便多了，上面这段代码最引人注目的地方就是<code>Runnable r = ()-&gt;System.out.println(&quot;hello java&quot;);</code>它<strong>把一个匿名函数（λ表达式）赋给一个接口，匿名函数就是接口内唯一抽象函数的实现</strong>,然后把实现函数后的接口传给<code>Thread</code>,真是不得不佩服java设计者的思想（其实其他语言早就有了，java8才支持这个）。上面的代码还能继续简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;System.out.println(<span class="hljs-string">&quot;hello java&quot;</span>));<br></code></pre></td></tr></table></figure><p>上面就是λ表达式的神奇作用了，我们把这样的接口实现叫<strong>函数式的接口</strong>。顺便一说，函数式接口的传入参数类型已经在要实现的抽象函数里面定义了，因此我们的参数列表不用再写类型，java编译器会自动判断，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Demo</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(s-&gt;System.out.println(s));<br></code></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>出乎意料的是，上面的<code>Demo d = new Demo(s-&gt;System.out.println(s));</code>还能继续简化，如果匿名函数调用的是现成的方法，可以用<strong>class::method</strong>的方式进一步简化λ表达式表达式（莫名想到C++），如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">s-&gt;System.out.println(s)<span class="hljs-comment">//简化成下面的class::method,甚至参数都不要了</span><br>System.out::println<br></code></pre></td></tr></table></figure><p>上面两行代码的效果完全是一模一样的，你可能会问编译器怎么知道要打印啥呢？这个其实不用担心，java编译器可以自动识别，再比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(x,y)-&gt;Math.pow(x,y)<br>Math::pow<br></code></pre></td></tr></table></figure><p>下面两行是一模一样的，我们需要指名的是”干什么“，至于参数处理问题交给编译器自己去分析就好了。除了<strong>class::method</strong>外，我们还能通过相对路径（class是绝对路径）来进行方法引用，主要就是通过<strong>this::method</strong>和<strong>super::method</strong>来引用本类和父类的方法。</p><p>方法引用之外还能用<strong>class::new</strong>来进行构造器引用，由于这样的用法很不常见，这里就不细说了。</p><h3 id="λ表达式的作用域问题"><a href="#λ表达式的作用域问题" class="headerlink" title="λ表达式的作用域问题"></a>λ表达式的作用域问题</h3><p>λ表达式作为一个独立的”动作“，它虽然<strong>可以访问到其外部的变量，但无法修改</strong>，因此个人不建议在λ表达式中访问外部变量，让它保持独立是最好的选择。</p><p>终于完了，可把我累死了。。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>闲聊</title>
    <link href="/posts/9f25/"/>
    <url>/posts/9f25/</url>
    
    <content type="html"><![CDATA[<p>说好坚持每周一篇的，但是做不到啊，这篇主要来说说这一个月干了啥吧。。。最简单的概括就是，能感到自己在飞速进步，也能感受到自己有多菜。</p><span id="more"></span><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>暑假期间把《大话数据结构》基本看完了，大部分数据结构自己用C&#x2F;Java写了一遍，但还有几个没写，要么太懒，要么太难，最后我也在八月底画了一张图<br>!<img src="http://wx2.sinaimg.cn/mw690/007bwgzIly1fv77dvufwnj31me1r5h5e.jpg" alt="image"><br>学完数据结构后的收获很大，我不知道上个世纪的数学家或者计算机学家发挥了多大的脑洞或者尽了多大的努力才发现各式各样的数据结构，各式各样的算法。最为印象深刻的当然是那个让我花了最多时间的BST(二叉查找树)以及它各式各样的变种。看完数据结构也预示着我大二上的计算机必修课程基本全部自学完。</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>因为学安卓看的java,这门语言真的把我迷住了，数据抽数据结构的零碎时间补充的java相关知识，主要干的事情有下面这些吧：</p><p>知识点：</p><ul><li>重新认识异常抛出</li><li>重新学java集合</li><li>简单学习java多线程</li><li>javaFx图形界面程序开发</li><li>理解λ表达式</li><li>简单认识java泛型</li><li>JDBC的基本使用</li><li>简单了解jsp</li><li>学习Spring</li><li>学习Mybatis<br>项目：</li><li>辅助一个已在工作的工程师完成一个小型java web项目</li><li>用javaFX开发“一本糊涂账”<br>其他：</li><li>购置《java核心技术II》和一本SSM框架的书</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>这个数据也安装学习了一些软件（虽然基本都是一知半解）</p><ul><li>Ai的基本操作</li><li>blender简单建模</li><li>svn的使用</li><li>tomcat服务器的使用</li><li>IDEA的快捷键</li><li>QtCreator的安装</li><li>Navicat使用</li><li>MySQL Server安装</li></ul><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><p>由于要睡觉了就简单写一下吧：</p><ul><li>简单静态网页（html,css和javascript）</li><li>xml的相关知识（dtd约束等）</li><li>简单回顾了一些C++的面向对象，帮同学完成Qt桌面程序，更加坚定了我选java的决心</li><li>MySQL常用语句（建表，增删查找等）</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个暑假学的东西很多很杂,主要的东西就是数据结构和java,杂七杂八的绝大多数是为了javaEE服务的，还有的一点点主要是出于兴趣了，对了还有一点忘说了，最近已经开始看计算机组成原理的相关东西了（大二下必修课），整个大二的中心是在不影响自己专业课的情况下去学java和一些计算机的大二必修课，一心一意向着自己所热爱的东西去努力。共勉。</p>]]></content>
    
    
    <categories>
      
      <category>闲聊</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/posts/dfe1/"/>
    <url>/posts/dfe1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题图来源：<a href="http://www.nipic.com/show/3/77/30ba1a57bcec814c.html">http://www.nipic.com/show/3/77/30ba1a57bcec814c.html</a>,侵删</p></blockquote><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>在说最小生成树之前我们必须明确的几点：</p><ul><li>在之前的无向图基础上给每一条边加上权值（weight）后，这个图就是加权图，每一边的权值是可以相加和可以比较大小的（权值一般是数字）</li><li>对于任意一棵树，欧拉给出了下面的等量关系$V &#x3D; E + 1$</li></ul><p>我还真不知道咋形容生成树是啥。这么说吧，我们把一张图看成一个交通网，顶点就是地点，边就是路，边的权值就是路的长度。现在有拆迁办来了，他们要在满足任意两地之间可以来往的基本前提（两地之间的路可以有其他的点）下只保留尽可能少数量的路。剩下的路和地点构成的图是原来的图的<strong>子图</strong>。不难发现剩下的路是没有环的（通过欧拉公式证明，略取），也就是一棵树，我们把这样的树叫做该图的<strong>生成树</strong>，而所有生成树中所有边的权值之和最小的树称之为该图的<strong>最小生成树</strong>，最小生成树有如下性质</p><ul><li><p>最小生成树有<code>V</code>个顶点(包含了图的所有顶点),<code>V-1</code>条边</p></li><li><p>一个图最小生成树不唯一</p></li></ul><p>下面就来说说最小生成树的算法实现</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>prim算法可以说很简单易懂，但自己的代码不忍直视，所以下面讲原理，代码就不贴了QAQ</p><blockquote><p>prim算法的证明是图论问题，涉及的数学比较多，这里也不说了，主要看看实现步骤：</p></blockquote><ul><li><p><strong>prim算法是子树一步一步扩展的过程</strong>，每经历一步，子树就多一条边，经过<code>v-1</code>次后子树有<code>v-1</code>条边，此时算法结束；</p></li><li><p><strong>prim算法走的是贪心策略</strong>，每一步都寻找与自己相邻边中权值最小的边；</p></li></ul><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索（BFS）</title>
    <link href="/posts/4708/"/>
    <url>/posts/4708/</url>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>之前我们说到过图是一种十分混乱的数据结构，因此对图的遍历当然没有对表和树那样清晰和明确。在这一篇和下一篇中我会详细介绍图的两种遍历：<strong>广度优先遍历（BFS）</strong>和<strong>深度优先遍历（DFS）</strong></p><blockquote><p>对于<code>广度优先遍历</code>和<code>广度优先搜索</code>请不要过于纠结，其实是一样的</p></blockquote><p>对于广度优先遍历，我们需要根据提供的初始点给出遍历结果，这里的遍历结果用打印来表示，因此我们的任务是<strong>对于给定的顶点x,利用DFS不重复地打印所有顶点</strong>。下面给出方法的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>bfs and print</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>说明：用java不用c的原因是：我们关注的是算法的本身，用c写会有好多不利于我们理解的细节（比如一堆指针的指向），而用java可以封装没有必要的东西，把关注点更多放在算法本身上。</p></blockquote><p>下面来看一下到底什么是BFS.</p><h1 id="BFS的基本策略"><a href="#BFS的基本策略" class="headerlink" title="BFS的基本策略"></a>BFS的基本策略</h1><p>我们以题图（如下）来进行讲解（设遍历的起始点是顶点3）</p><p><img src="http://ws2.sinaimg.cn/mw690/007bwgzIly1fu12j125rwj31270juwfk.jpg"></p><h2 id="遍历的顺序"><a href="#遍历的顺序" class="headerlink" title="遍历的顺序"></a>遍历的顺序</h2><p>BFS类似<strong>树的层次遍历</strong>，也就是一层一层地往下遍历，我们这里定义一下：<strong>在遍历过程中，与第n层直接相连且未定义层数的点为第n+1层</strong>，下面是个例子：</p><ol><li><p>毫无疑问，顶点3是第一层</p></li><li><p>与3只接相连的有顶点4和顶点0，那么顶点4和顶点0是第2层</p></li><li><p>与4相连的点有3，0，2，由于3和0已经是第一二曾，因此未被定义的点只有2，所有顶点2是第三层同意顶点1也是第三层（因为顶点1与处于第二层的顶点0直接相连）</p></li><li><p>所有的点已经定义，分层结束，得到如下的图：</p><p><img src="http://wx4.sinaimg.cn/mw690/007bwgzIly1fu15u3n95sj30u50ibq3o.jpg" alt="image"><br>我们的BFS就是按照第一层到第n层进行遍历的比如这个图的遍历顺序就是： <code>3-&gt;(4,0)-&gt;(1,2)</code>(至于4和0，1和2的顺序得看图是怎么存储的，和BFS的关系不大)。</p></li></ol><h2 id="遍历的实现"><a href="#遍历的实现" class="headerlink" title="遍历的实现"></a>遍历的实现</h2><p>根据上面的分析我们已经能大致分析出遍历的实现了（打印的点即为已经遍历的点）：</p><ol><li>打印顶点3</li><li>找到与顶点3相邻的（且未被打印的）顶点（这里是4和0）</li><li>打印顶点4</li><li>找到与顶点4相邻的（且未被打印的）顶点…</li><li>打印顶点0</li><li>找到与顶点0相邻的顶点（且未被打印的）顶点..</li><li>…</li></ol><p>这样算法流程就清晰了起来。我们还需要注意一点，<strong>先找到的点总是先打印的</strong>，比如我们找到4和0后，先打印4，然后找与4相邻的点，再打印0，然后打印刚刚找到的和4相邻的点……不知聪明的你有没有发现这其中隐含了一个顶点的队列：</p><ul><li>找到与当前点相邻且为被打印的点是一个<strong>入队</strong>的过程</li><li>打印顶点是一个<strong>出队</strong>的过程</li></ul><p>下面是入队和出队的全过程：</p><ul><li>3（3入队）</li><li>340（由3找到的4，0入队）</li><li>40（与3相邻的点找完，3出队）</li><li>402（由4找到2，2入队）</li><li>02（与4相邻的点找完，4出队）</li><li>021（由0找到1，1入队）</li><li>21（与0相邻的点找完，0出队）</li><li>1（没有与2相邻的，2出队）</li><li>（没有与1相邻的，1出队）</li></ul><p>还有最后一个问题就是<strong>如何判断该点是否已经打印</strong>，这个问题很简单，打印的时候用一个数组<code>visited[]</code>存一下，在入队之前检查数组里面的情况，未被打印就入队就ok.</p><p>这样整个过程以及逻辑实现就十分清晰了，只剩最后的代码实现</p><h2 id="代码实现（以邻接图的存储为例）"><a href="#代码实现（以邻接图的存储为例）" class="headerlink" title="代码实现（以邻接图的存储为例）"></a>代码实现（以邻接图的存储为例）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span>&#123;<br>    <span class="hljs-comment">//参观过为true</span><br>    <span class="hljs-type">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[V];<br>    <span class="hljs-comment">//第一个遍历的节点已经访问，设为true</span><br>    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//初始化队列</span><br>    visited[s] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//标记第一个点为已经打印</span><br>    queue.add(s);<span class="hljs-comment">//把第一个节点加入队列</span><br>    <br><span class="hljs-keyword">while</span> (queue.size()!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//全部出队==遍历结束</span><br>        s = queue.poll();<span class="hljs-comment">//从队列出一个顶点</span><br>        System.out.println(s +<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//打印该顶点</span><br>        <span class="hljs-comment">//遍历与s顶点连接的顶点</span><br>        Iterator&lt;Integer&gt; i = adj[s].listIterator();<br>        <span class="hljs-keyword">while</span> (i.hasNext())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.next();<span class="hljs-comment">//若该节点没有访问</span><br>            <span class="hljs-keyword">if</span>(!visited[n])&#123;<br>                visited[n] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//访问该节点</span><br>                queue.add(n);<span class="hljs-comment">//加入队列</span><br>            &#125;<br>        &#125;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成的BFS,代码理解还是不难的，下一次应该是DFS（深度优先搜索）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索(DFS)</title>
    <link href="/posts/4854/"/>
    <url>/posts/4854/</url>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>具体见我的上一篇<a href="http://localhost:4000/2018/08/07/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88bfs%EF%BC%89/">广度优先搜索</a></p><h1 id="DFS的基本策略"><a href="#DFS的基本策略" class="headerlink" title="DFS的基本策略"></a>DFS的基本策略</h1><p>我们还是以上回的那个图为例：</p><p><img src="http://ws2.sinaimg.cn/mw690/007bwgzIly1fu12j125rwj31270juwfk.jpg"></p><h2 id="遍历的顺序"><a href="#遍历的顺序" class="headerlink" title="遍历的顺序"></a>遍历的顺序</h2><p>个人觉得DFS比BFS更好理解，简单来说就是<strong>一条路走到黑，没路再回头的策略</strong>的策略。我们先来看这个例子（这回从0开始）：</p><ul><li>打印0，找一个和0相邻的（未被打印）顶点        （这里4和0之间选4）</li><li>打印4，找一个和4相邻的（未被打印）顶点        （这里只有3）</li><li>打印3，找和3相邻的（未被打印）顶点                （然而并没有）</li><li>回退到4，找到一个和4相邻的（未被打印）顶点（找到了2）</li><li>打印2，找一个和2相邻的（未被打印）顶点        （找到了1）</li><li>打印1，找和1相邻的（未被打印）顶点                   （没有）</li><li>回退，找一个和2相邻的（未被打印）顶点           （  没有）</li><li>回退，找一个和4相邻的（未被打印）顶点           （没有）</li><li>回退，找一个和1相邻的（未被打印）顶点             （没有）</li><li>结束</li></ul><p>不难发现，这和我们走迷宫的套路是一样的(一直往左手边的路走，找不到了回退)，没错，DFS一个最经典的应用便是走迷宫</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>根据上面的分析，不难发现DFS是一个<strong>递归</strong>算法，循环调用以达遍历目的，这里为了标记已经打印的点，也采用一个<code>visited[]</code>数组来存储是否打印的情况。代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">DFSUtil</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">boolean</span> visited[])</span>&#123;<span class="hljs-comment">//把遍历部分单独抽出</span><br><span class="hljs-comment">//标记当前的点为已经标记</span><br>visited[v] = <span class="hljs-literal">true</span>;<br>System.out.print(v+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//打印</span><br>Iterator&lt;Integer&gt; i = adj[v].listIterator();<br><span class="hljs-keyword">while</span> (i.hasNext())&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.next();<br><span class="hljs-keyword">if</span>(!visited[n])<br>DFSUtil(n,visited);<span class="hljs-comment">//遍历与当前节点相邻的所有未被打印节点</span><br>&#125; <br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span>&#123;<br><span class="hljs-type">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-built_in">this</span>.V];<br>DFSUtil(v,visited);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面再来看看非递归实现</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>类比BFS的队列存储，BFS可以利用<strong>栈</strong>来存储：</p><ul><li><strong>搜索</strong>是<strong>入栈</strong>的过程：当<strong>栈顶</strong>顶点还有相邻的顶点的时候就将该顶点入栈</li><li><strong>打印</strong>是<strong>出栈</strong>的过程：当<strong>栈顶</strong>顶点已经没有相邻的顶点时就将该顶点出栈（也就是打印的过程）</li></ul><p>下面是一个实例分析：（还是这个图）</p><p><img src="http://ws2.sinaimg.cn/mw690/007bwgzIly1fu12j125rwj31270juwfk.jpg"></p><ul><li><p>（空栈）</p></li><li><p>0 （0入栈）</p></li><li><p>04（0和4相邻，4入栈）</p></li><li><p>043（3和4相邻，3入栈）</p></li><li><p>04（没有顶点和3相邻，3出栈,打印3）</p></li><li><p>042（与栈顶顶点相邻的还有2，2入栈）</p></li><li><p>0421（1和2相邻，1入栈）</p></li><li><p>042（没有顶点和1相邻，1出栈,打印1）</p></li><li><p>04（没有顶点和2相邻，2出栈,打印2）</p></li><li><p>0（没有顶点和4相邻，4出栈,打印4）</p></li><li><p>（没有顶点和0相邻，0出栈,打印0）</p></li></ul><p>这样当栈为空的时候整个遍历就完全结束了，下面是代码（基本和BFS一模一样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span>&#123;<br>    <span class="hljs-comment">//参观过为true</span><br>    <span class="hljs-type">boolean</span> visited[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[V];<br>    <span class="hljs-comment">//第一个遍历的节点已经访问，设为true</span><br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    visited[s] = <span class="hljs-literal">true</span>;<br>    stack.push(s);<span class="hljs-comment">//把已经访问的节点加入队列</span><br><br>    <span class="hljs-keyword">while</span> (stack.size()!=<span class="hljs-number">0</span>)&#123;<br>        s = stack.pop();<span class="hljs-comment">//弹出栈顶元素并打印</span><br>        System.out.print(s+<span class="hljs-string">&quot; &quot;</span>);<br>        Iterator&lt;Integer&gt; i = adj[s].listIterator();<br>        <span class="hljs-keyword">while</span> (i.hasNext())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i.next();<span class="hljs-comment">//若该节点没有访问</span><br>            <span class="hljs-keyword">if</span>(!visited[n])&#123;<br>            visited[n] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//访问该节点</span><br>            stack.push(n);<span class="hljs-comment">//加入队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就这样，图的遍历结束了。写这两篇加深了我对图的搜索的认识，后面就是最小生成树和最短路径算法了，游戏才刚刚开始。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/posts/b7fa/"/>
    <url>/posts/b7fa/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的简介"><a href="#图的简介" class="headerlink" title="图的简介"></a>图的简介</h2><p>图（graph）是继表，树，之后一个更加混乱的数据结构，表是<strong>线性</strong>的，树好歹具有<strong>层次性</strong>，而图，再怎么看也啥性质也没有。下面就是一张图，用混乱来形容真的毫不为过(记住这个图，以后还会用到)</p><span id="more"></span><p><br><img src="http://wx3.sinaimg.cn/mw690/007bwgzIly1ftza8rtoejj30h30b7q36.jpg" alt="image"></p><p>十分通俗地，字母A-G叫做图的<strong>顶点(Vertices )</strong>,用V来表示，连接这些顶点的黑灰色的边就叫做<strong>边(Edge)</strong>,用E来表示，图就是这些点和边的集合：(V,E).具体可以参见<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)">wiki–图</a></p><p>注：有向图，无向图，连通图等这里不过多介绍，默认是无向图</p><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><p>既然我们要写图的数据结构就得想办法用代码把图表示出来，总不能让计算机去图像识别吧 :neutral_face: 。下面来看一看图的存储。</p><p>仔细想想一个图可以有两种方式来确定它的特征：</p><ul><li>顶点以及顶点之间是否相连（是否有边）</li><li>边以及边与边是否有交点（0，1，2）个</li></ul><p>不用多说第一种表示方法更加简单明了吧。。。。 :no_mouth: 这样一来就清晰好多了，我们需要用一个数据集合描述<strong>点及点与点之间的关系</strong>，下面来看两种表示法。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>设有<code>V</code>个点，用一个<code>v*v</code>的矩阵$A &#x3D; a_{ij}$来表示点与点是否连接，如果点1和点2之间有边，那么$a_{12}&#x3D;a_{21} &#x3D; 1$，如果点3和4之间没有边相连，那么$a_{34}&#x3D;a_{43} &#x3D; 0$,这样一个用一个<code>v*v</code>的矩阵就能唯一表示一个含v个顶点的图了。如下图是一个例子:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">mermaid<br><br>graph LR<br><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[1]</span>-<span class="hljs-attr">--D</span><span class="hljs-selector-attr">[4]</span><br><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[1]</span>-<span class="hljs-attr">--B</span><span class="hljs-selector-attr">[2]</span><br><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[1]</span>-<span class="hljs-attr">--C</span><span class="hljs-selector-attr">[3]</span><br>D<span class="hljs-selector-attr">[4]</span>-<span class="hljs-attr">--B</span><span class="hljs-selector-attr">[2]</span><br>C<span class="hljs-selector-attr">[3]</span>-<span class="hljs-attr">--D</span><span class="hljs-selector-attr">[4]</span><br></code></pre></td></tr></table></figure><p>如上一个含有四个顶点的图有（1，3），（1，4），（1，2），（2，4），（3，4）五条边，用矩阵表示为：</p><p>$$ \begin{bmatrix} 0 &amp; 1 &amp; 1&amp;1 \ 1 &amp; 0 &amp; 0&amp;1 \ 1 &amp; 0&amp; 0&amp;1 \ 1&amp;1&amp;1&amp;0 \ \end{bmatrix} $$ </p><p>聪明的你一定不难发现方阵用数组来存储是最方便的吧,下面我给出java代码:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//MyGraph.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyGraph</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> V;<span class="hljs-comment">//顶点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span>[][];<span class="hljs-comment">//数组</span><br>    MyGraph(<span class="hljs-built_in">int</span> v)&#123;<span class="hljs-comment">//构造器</span><br>        <span class="hljs-keyword">this</span>.V = v;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">array</span> = new <span class="hljs-built_in">int</span>[V][V];<span class="hljs-comment">//初始化</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">void</span> addEdge(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b)&#123;<span class="hljs-comment">//添加边的过程就是让矩阵上两个对称的点的距离等于1的过程</span><br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">array</span>[a<span class="hljs-number">-1</span>][b<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">array</span>[b<span class="hljs-number">-1</span>][a<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>实际上用矩阵存储图是十分耗内存的，有n个点的图就要n<em>n的矩阵，所需的存储空间以平方倍增长，这样明显极为不划算，下面提供一种更好也更常用的图的存储方法：*<em>邻接表</em></em></p><p>邻接表的思维和邻接矩阵差不多，都是<strong>用一个数据集合来表示点以及点点之间是否有边</strong>，邻接表的思路是这样的：</p><ul><li><p>对于有V个顶点的图，用V个链表来存储点和点之间是否有边(也就是一个链表数组)</p></li><li><p>每个顶点对应一个链表，如果在顶点A与另一顶点B之间添加了一条边，那么让A对应的链表插入B,当然B对应的链表也要插入A</p><p>下面有一张示意图：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">mermaid<br><br>graph LR<br>subgraph headerPointer LinkList array<br><span class="hljs-selector-tag">A</span>-<span class="hljs-attr">--B</span><br><span class="hljs-selector-tag">B</span>-<span class="hljs-attr">--C</span><br>C-<span class="hljs-attr">--D</span><br>D-<span class="hljs-attr">--E</span><br>end<br><span class="hljs-selector-tag">A</span>--&gt;F<span class="hljs-selector-attr">[B]</span><br>F<span class="hljs-selector-attr">[B]</span>--&gt;G<span class="hljs-selector-attr">[C]</span><br><span class="hljs-selector-tag">B</span>--&gt;H<span class="hljs-selector-attr">[A]</span><br>C--&gt;<span class="hljs-selector-tag">I</span><span class="hljs-selector-attr">[A]</span><br><span class="hljs-selector-tag">I</span>--&gt;J<span class="hljs-selector-attr">[E]</span><br>E--&gt;K<span class="hljs-selector-attr">[C]</span><br><br></code></pre></td></tr></table></figure><p>简单解释一下，这个图有ABCDE五个顶点，<code>A-&gt;B-&gt;C</code>表示A与B和A与C之间有一条边（切记不是A与B,B与C）,<code>C-&gt;A-&gt;E</code>表示C与A,C与E之间有一条边。</p><p>这里每个顶点对应的链表里面节点与节点之间没有前驱和后继的关系,这一点十分重要，最后给出java代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> V;<span class="hljs-comment">//节点个数</span><br>    <span class="hljs-comment">//每个节点对应的linkList</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.V = v;<br>        <span class="hljs-keyword">this</span>.adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;v;i++)<br>            adj[i] = <span class="hljs-keyword">new</span> LinkedList();<br>    &#125;<br><br>    <span class="hljs-comment">//添加边</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> v,<span class="hljs-built_in">int</span> w</span>)</span>&#123;<br>        adj[v].<span class="hljs-keyword">add</span>(w);<br>        adj[w].<span class="hljs-keyword">add</span>(v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇主要说明了（无向）图是啥，并介绍了两种图的存储结构：邻接矩阵和邻接表。在这里说明一下，以后的有关图的博客都以邻接表作为存储方法。</p><p>当然科学家的脑洞是无限的，图肯定不止这两种存储方法，其他方法不作介绍，如想了解请自行百度&#x2F;谷歌。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQLite中的建表</title>
    <link href="/posts/f6fd/"/>
    <url>/posts/f6fd/</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>面向的是完全没数据库基础的自己</p><h2 id="创建表-create-a-table"><a href="#创建表-create-a-table" class="headerlink" title="创建表(create a table)"></a>创建表(create a table)</h2><p>先来看看SQL中的建表语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> TableName (<br>id <span class="hljs-type">integer</span> ,<br>author <span class="hljs-type">text</span>,<br>price <span class="hljs-type">real</span>,<br>pages <span class="hljs-type">integer</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">text</span>)<br></code></pre></td></tr></table></figure><p>括号里面里面每组是代表一个数据的一项，左端是键名(id,author等)，右边的是基本数据类型，<code>text</code>是文本字符串，<code>integer</code>是带符号的整数，<code>real</code>是浮点数。<br>括号外面已经很明显了，表示创建名为<code>TableName</code>的表。</p><p>而把建表语句转换成字符串后就是这样（其实是简单的字符串拼接）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> CREATE_TABLE = <span class="hljs-string">&quot;create table TableName (&quot;</span>+<br>            <span class="hljs-string">&quot;id integer ,&quot;</span>+<br>            <span class="hljs-string">&quot;author text,&quot;</span>+<br>            <span class="hljs-string">&quot;price real,&quot;</span>+<br>            <span class="hljs-string">&quot;pages integer,&quot;</span>+<br>            <span class="hljs-string">&quot;name text)&quot;</span>;<br></code></pre></td></tr></table></figure><p>下面的代码展示了如何利用button监听来创建表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">button2.setOnClickListener(v -&gt;&#123;<br>            <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbHelper.getWritableDatabase();<br>            db.execSQL(CREATE_TABLE);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>这样当你点了按钮之后数据库就会多出来一个名为TableName的表。但是如果你第二次点击时应用会闪退，，，因为这个表已经存在，再次点击会发生冲突，解决方法很简单,把<code>create table TableName</code>改成<code>create table if not exists TableName</code>即可。这就是一个完整的建表过程。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQlite(1)——数据库的创建</title>
    <link href="/posts/4b04/"/>
    <url>/posts/4b04/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android自带了SQLite数据库，这一篇主要讲SQlite数据库的创建以及自己的一些总结</p><span id="more"></span><h2 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h2><p>SQlite 的创建需要如下步骤：</p><ul><li>自定义继承<code>SQLiteOpenHelper</code>的子类</li><li>获取该类的实例</li><li>调用<code>getWritableDatabase()</code>方法</li></ul><h3 id="自定义继承SQLiteOpenHelper的子类"><a href="#自定义继承SQLiteOpenHelper的子类" class="headerlink" title="自定义继承SQLiteOpenHelper的子类"></a>自定义继承<code>SQLiteOpenHelper</code>的子类</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.agno3.databasetest;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.database.sqlite.SQLiteDatabase;<br><span class="hljs-keyword">import</span> android.database.sqlite.SQLiteOpenHelper;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDatabaseHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span>  Context mContext;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> context 上下文</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> name 数据库名</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> factory 不知道 一般填null</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> version 数据库版本</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDatabaseHelper</span><span class="hljs-params">(Context context, String name, SQLiteDatabase.CursorFactory factory, <span class="hljs-keyword">int</span> version)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, name, factory, version);<br>        <span class="hljs-comment">//构造器内传入上下文</span><br>        <span class="hljs-keyword">this</span>.mContext = context;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;<br>    <span class="hljs-comment">//这个方法在数据库被创建的时候执行</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;<br>      <span class="hljs-comment">//这个方法在数据库版本更新的时候执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取该类的实例以及创建数据库"><a href="#获取该类的实例以及创建数据库" class="headerlink" title="获取该类的实例以及创建数据库"></a>获取该类的实例以及创建数据库</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//MainActivity的oncreate方法</span><br>protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>       super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>       set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>       <span class="hljs-comment">//获取MyDatabaseHelper的实例</span><br>       MyDatabaseHelper dbHelper = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MyDatabaseHelper(<span class="hljs-params">this</span>,<span class="hljs-string">&quot;BookStore.db&quot;</span>,<span class="hljs-params">null</span>,1)</span>;<br>       Button button = find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">create_database</span>)</span>;<br>       <span class="hljs-comment">//执行getWritableDatabase()方法</span><br>       button.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">v</span>-&gt; <span class="hljs-params">dbHelper</span>.<span class="hljs-params">getWritableDatabase</span>()</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在执行getWritableDatabase()方法后数据库被创建，但是个没表的新库，会自动生成一个<code>android_metadata</code>的table,与此同时，MyDatabaseHelper类中的<code>onCreate()</code>方法被执行。<br>getWritableDatabase()的返回值是一个<strong>SQLiteDatabase</strong>对象，在第二次执行getWritableDatabase()方法时数据库不会再被创建，<code>onCreate()</code>也不会再次执行，此时可以利用<br><code>SQLiteDatabase db = dbHelper.getWritableDatabase()</code>来获取该数据库的实例，从而对数据库进行进一步操作(增删查改等)。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次简单的图灵api的使用</title>
    <link href="/posts/bbe7/"/>
    <url>/posts/bbe7/</url>
    
    <content type="html"><![CDATA[<p>今天做了一个小聊天机器人，效果如图，感觉不错就来分享记录一下。</p><span id="more"></span><p><img src="http://ws3.sinaimg.cn/mw690/006dLm93ly1frnv9ukstwj30f00qomxm.jpg" alt="image"></p><h2 id="注册图灵机器人"><a href="#注册图灵机器人" class="headerlink" title="注册图灵机器人"></a>注册图灵机器人</h2><p>在<a href="http://www.tuling123.com/">图灵机器人</a>官网上注册一个账号，并添加一个机器人，获取<code>apikey</code>备用，<code>apikey</code>是外界和机器人交流的唯一接口，注意不要泄露给别人。</p><p><img src="http://ws3.sinaimg.cn/mw690/006dLm93ly1frnvtbh5o1j307m02rwea.jpg" alt="image"></p><h2 id="通过apikey获取答复"><a href="#通过apikey获取答复" class="headerlink" title="通过apikey获取答复"></a>通过<code>apikey</code>获取答复</h2><p>该过程的实质是一个post,请求，也就是携带信息向某个url进行post请求。<br>携带的信息是两个<strong>键值对</strong>，容易猜到一个是<code>apikey</code>,一个是<code>text</code>,也就是你要发出去的消息，而请求的url由图灵官方提供，为<a href="http://www.tuling123.com/openapi/api">http://www.tuling123.com/openapi/api</a><br>这样思路就明了了，下面是代码实现。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python通过requests实现"><a href="#python通过requests实现" class="headerlink" title="python通过requests实现"></a>python通过<code>requests</code>实现</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import requests #导入库<br>s = &#123;<br><span class="hljs-string">&quot;key&quot;</span>:<span class="hljs-string">&quot;your apikey&quot;</span>,<br>    <span class="hljs-string">&quot;info&quot;</span>:<span class="hljs-string">&quot;你多大了&quot;</span><br>&#125;<br>r = requests<span class="hljs-selector-class">.post</span>(<span class="hljs-string">&quot;http://www.tuling123.com/openapi/api&quot;</span>,data=s)#post请求<br>r<span class="hljs-selector-class">.encoding</span> = r<span class="hljs-selector-class">.apparent_encoding</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(r.text)</span></span><br></code></pre></td></tr></table></figure><p>返回的<code>r.text</code>是<code>json</code>信息，进行简单的字符串提取就ok</p><h3 id="android通过Okhttp实现"><a href="#android通过Okhttp实现" class="headerlink" title="android通过Okhttp实现"></a>android通过<code>Okhttp</code>实现</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void get<span class="hljs-constructor">Content(String <span class="hljs-params">s</span>)</span><br>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<span class="hljs-comment">//new thread</span><br><span class="hljs-keyword">try</span> &#123;<br>OkHttpClient client = <span class="hljs-keyword">new</span> <span class="hljs-constructor">OkHttpClient()</span>;<br>RequestBody body = <span class="hljs-keyword">new</span> FormBody.<span class="hljs-constructor">Builder()</span><br>.add(<span class="hljs-string">&quot;key&quot;</span>,key)<span class="hljs-comment">//key is your apikey</span><br>.add(<span class="hljs-string">&quot;info&quot;</span>,s)<br>.build<span class="hljs-literal">()</span>;<span class="hljs-comment">//request body</span><br>Request request = <span class="hljs-keyword">new</span> Request.<span class="hljs-constructor">Builder()</span><br>.url(<span class="hljs-string">&quot;http://www.tuling123.com/openapi/api&quot;</span>)<br>.post(body)<br>.build<span class="hljs-literal">()</span>;<br>Response response = client.<span class="hljs-keyword">new</span><span class="hljs-constructor">Call(<span class="hljs-params">request</span>)</span>.execute<span class="hljs-literal">()</span>;<br>String s1 = response.body<span class="hljs-literal">()</span>.<span class="hljs-built_in">string</span><span class="hljs-literal">()</span>;#get the content<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(<span class="hljs-string">&quot;s&quot;</span>,s1 );<span class="hljs-comment">//s1 is the resuests(json)</span><br>&#125;catch (Exception e)&#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br>&#125;<br>).start<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个app的代码可参考<a href="https://github.com/hhhxiao/Chat">Chat</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>相量分析</title>
    <link href="/posts/adeb/"/>
    <url>/posts/adeb/</url>
    
    <content type="html"><![CDATA[<p>这篇讨论的是正弦电路下<strong>电阻，电容，电感</strong>在正弦稳态下的电流和电压的相位关系，主要思路还是<strong>激励和响应</strong></p><span id="more"></span><h2 id="电阻"><a href="#电阻" class="headerlink" title="电阻"></a>电阻</h2><p>设激励的电压为：$u&#x3D;U_{m}sin(\omega t+\psi)$,对应的$\dot{U}&#x3D;U\angle \psi$<br>根据经典的<strong>欧姆定律</strong>，流经电阻R的的电流$i_{R}$有：<br>$$<br>i_{R} &#x3D; \frac{u}{R} &#x3D; \frac{U_{m}}{R} sin(\omega t+\psi)<br>$$<br>$i_{R}$对应的$\dot{I} &#x3D; \frac{U_{m}}{R} \angle \psi$,于是在复平面中$\dot{U}$和$\dot{I}$是同方向的相量（辐角均为$\psi$）,模的绝对值之比为定值电阻的阻值。</p><h2 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h2><p>根据电感的性质$U&#x3D;L\frac{di}{dt}$：用电流源作为激励是更好的选择：$i&#x3D;I_{m}sin(\omega t+\psi)$,对应的$\dot{I}&#x3D;I\angle \psi$,此时的电压u:<br>$$<br>u_{L}&#x3D;L\frac{di}{dt}&#x3D;L\omega I_{m}cos(\omega  t+\psi)&#x3D;L\omega I_{m}sin(\omega t+\psi+\frac{\pi}{2})<br>$$<br>对应的$\dot{U} &#x3D; L\omega I\angle{(\psi+\frac{\pi}{2})}$<br>于是：($\angle{\frac{\pi}{2}}&#x3D;0+1*j &#x3D; j$)<br>$$<br>\frac{\dot{U}}{\dot{I}}&#x3D;\frac{L\omega I\angle{(\psi+\frac{\pi}{2}})}{I\angle \psi}&#x3D;\omega L\angle{\frac{\pi}{2}}&#x3D;j\omega L<br>$$<br>可见在复平面内电感的电压相量超前电流相量$\frac{\pi}{2}$，其模的比值为$L\omega$.</p><h2 id="电容"><a href="#电容" class="headerlink" title="电容"></a>电容</h2><p>根据电容的性质$iC\frac{du}{dt}$：用电压源作为激励是更好的选择：$u&#x3D;U_{m}sin(\omega t+\psi)$,对应的$\dot{U}&#x3D;U\angle \psi$，此时的电流i:<br>$$<br>i_{C}&#x3D;C\frac{du}{dt}&#x3D;C\omega U_{m}cos(\omega t+\psi)&#x3D;C\omega U_{m}sin(\omega t+\psi+\frac{\pi}{2})<br>$$<br>对应的$\dot{I} &#x3D; C\omega U\angle{(\psi+\frac{\pi}{2})}$<br>于是：<br>$$<br>\frac{\dot{U}}{\dot{I}}&#x3D;\frac{U\angle \psi}{C\omega U\angle{(\psi+\frac{\pi}{2})}}&#x3D;\frac{1}{\omega C}\angle{-\frac{\pi}{2}}&#x3D;\frac{1}{j\omega C}<br>$$<br>可见在复平面内电容的电压相量滞后电流相量$\frac{\pi}{2}$，其模的比值为$frac{1}{\omega L}$.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上述计算是正弦稳态电路分析的基础，理解了才在后面的学习中更加轻松。。(个人原因没图片展示)</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正弦稳态1——复数</title>
    <link href="/posts/a4c5/"/>
    <url>/posts/a4c5/</url>
    
    <content type="html"><![CDATA[<h2 id="复数的表示"><a href="#复数的表示" class="headerlink" title="复数的表示"></a>复数的表示</h2><p>记$j &#x3D; \sqrt{-1}$是复数的基本单位，一个一般的复数记为：</p><span id="more"></span><blockquote><p>直角坐标：$A &#x3D; a+jb$<br>指数式：$A  &#x3D;\gamma e^{j\psi}$<br>三角式：$A &#x3D; \gamma(cos{\psi}+jsin{\psi})$</p></blockquote><p>三种形式可以互换：</p><blockquote><p>$\gamma &#x3D; \sqrt{a^{2}+b^{2}}$<br>$a &#x3D; \gamma cos{\psi}$<br>$b &#x3D; \gamma sin{\psi}$</p></blockquote><p>$\psi$称之为复数的<strong>辐角</strong>$\gamma$称之为复数的<strong>模</strong></p><p>而在电路分析里面复数$A$记为：<br>$$ A&#x3D;\gamma\angle\psi $$</p><h2 id="用复数表示正弦函数"><a href="#用复数表示正弦函数" class="headerlink" title="用复数表示正弦函数"></a>用复数表示正弦函数</h2><p>对于正弦函数$u &#x3D; U_{m}sin(\omega t+\psi_{u})$用复数表示为：<br>$$u &#x3D; U_{m}sin(\omega t+\psi_{u})$$<br>$$&#x3D;Im[U_{m}e^{j(\omega t+\psi_{u})}]&#x3D;Im[\sqrt{2}U\angle{\psi_{u}}e^{j\omega t}]$$<br>而在电路分析中常用<br>$$\dot{U} &#x3D;U\angle{\psi_{u}} $$<br>来表示正弦函数$u &#x3D; U_{m}sin(\omega t+\psi_{u})$,其中$U&#x3D;\frac{\sqrt{2}U_{m}}{2}$,$\dot{U}$称为$u$的<strong>相量</strong><br>这样就把复数和正弦函数联系起来了。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android 的广播</title>
    <link href="/posts/c61/"/>
    <url>/posts/c61/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>安卓的广播机制是一套十分灵活的<strong>消息&#x2F;信号</strong>的<strong>发送(send)&#x2F;接收（receive）</strong>机制，系统或者应用发出的广播（消息）可以覆盖几乎整个Android,因此广播机制是跨应用的，全局的。</p><span id="more"></span><h2 id="自定义个广播接收器-custom-BroadcastReceiver"><a href="#自定义个广播接收器-custom-BroadcastReceiver" class="headerlink" title="自定义个广播接收器(custom BroadcastReceiver)"></a>自定义个广播接收器(custom BroadcastReceiver)</h2><p>广播接收器的实质是一个监听器(接收到广播时执行相应的动作)，创建该监听器只需创建一个继承自<code>BroadcastReceiver</code>的类，并重写(override)其中的<code>onReceive</code>方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">BroadcastReceiver</span>;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">Context</span>;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">Intent</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br>public void onReceive(<span class="hljs-type">Context</span> context, <span class="hljs-type">Intent</span> intent) &#123;<br><span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>write what you want to do when receive a broadcast,such as a toast:</span><br><span class="hljs-type">Toast</span>.makeText(context,<span class="hljs-string">&quot;network changed&quot;</span> ,<span class="hljs-type">Toast</span>.<span class="hljs-type">LENGTH_SHORT</span> ).show();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就写好了自定义的receiver ，方法体里面写在收到广播的时候要干的事情。</p><h2 id="使用自定义的广播接收器-use-your-customized-BroadcastReceiver"><a href="#使用自定义的广播接收器-use-your-customized-BroadcastReceiver" class="headerlink" title="使用自定义的广播接收器(use your customized BroadcastReceiver)"></a>使用自定义的广播接收器(use your customized BroadcastReceiver)</h2><p>  要有广播才能使用广播接收器，目前先使用系统自带的广播(后面有自定义广播)，例如：在手机的网络情况发生变化时系统会发一条值为<code>android.net.conn.CONNECTIVITY_CHANGE</code>的广播。<br>  使用接收器的过程可以称为注册，注册分为<strong>动态注册</strong>和<strong>静态注册</strong>两种。</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>  首先利用<code>IntentFilter（意图筛选器）</code>把值为<code>android.net.conn.CONNECTIVITY_CHANGE</code>的广播筛选出来;然后利用<code>registerReceiver</code>方法进行注册；最后不要忘记在<code>onDestroy()</code>方法中取消注册：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//MainActivity.java</span><br><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><span class="hljs-keyword">import</span> android.content.<span class="hljs-type">IntentFilter</span>;<br><span class="hljs-keyword">import</span> android.support.v7.app.<span class="hljs-type">AppCompatActivity</span>;<br><span class="hljs-keyword">import</span> android.os.<span class="hljs-type">Bundle</span>;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">IntentFilter</span> intentFilter;<br><span class="hljs-keyword">private</span>  <span class="hljs-type">MyReceiver</span> myReceiver;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br><span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>setContentView(<span class="hljs-type">R</span>.layout.activity_main);<br>intentFilter = <span class="hljs-keyword">new</span> <span class="hljs-type">IntentFilter</span>();<br><span class="hljs-comment">//set the filter</span><br>intentFilter.addAction(<span class="hljs-string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span>);<br><span class="hljs-comment">//register the broadcast</span><br>myReceiver = <span class="hljs-keyword">new</span> <span class="hljs-type">MyReceiver</span>();<br>registerReceiver(myReceiver, intentFilter);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> void onDestroy() &#123;<br><span class="hljs-keyword">super</span>.onDestroy();<br>unregisterReceiver(myReceiver);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在运行app的时候，只要改变网络状态，app就会弹出一条toast显示“network changed”.但如果想在不运行这个app的时候也能进行监听，这就要靠<strong>静态注册</strong>了。</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册的思路和动态注册思路一样，只不过不在java代码中写,而是在<code>AndroidManifest.xml</code>进行注册，在<code>&lt;application&gt;&lt;application/&gt;</code>内加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyReceiver&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span>  </span><br><span class="hljs-tag">                    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;BatteryLife&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主要看<code>&lt;intent-filter&gt;</code>标签，同样起到了过滤效果。</p><h2 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h2><p>自定义广播通过<code>Intent</code>进行发送，应该还是好理解的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.agno3.MY_BROADCAST&quot;</span>);<br>sendBroadcast(intent);<br></code></pre></td></tr></table></figure><p>把它放在button的监听事件中（或其他触发方式）,点击按钮就能发送自定义的广播了，同样可以用自定义的接收器进行接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//custom receiver</span><br><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><br><span class="hljs-keyword">import</span> android.content.BroadcastReceiver;<br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.widget.Toast;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>write what you want to do when receive a broadcast</span><br>        Toast.makeText(context,<span class="hljs-string">&quot;button is clicked it has sent a broad cast&quot;</span> ,Toast.LENGTH_SHORT ).show();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后是MainActivity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MainActivity.java</span><br><span class="hljs-keyword">package</span> com.notice.agno3.receiver;<br><br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.content.IntentFilter;<br><span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.Button;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> IntentFilter intentFilter;<br>    <span class="hljs-keyword">private</span>  MyReceiver myReceiver;<br>    <span class="hljs-keyword">private</span> Button button;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//button</span><br>        button = findViewById(R.id.button);<br>        button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                <span class="hljs-comment">//send receiver</span><br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.agno3.MY_RECEIVER&quot;</span>);<br>                sendBroadcast(intent);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//set the filter</span><br>        intentFilter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>();<br>        intentFilter.addAction(<span class="hljs-string">&quot;com.agno3.MY_RECEIVER&quot;</span>);<br>        myReceiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyReceiver</span>();<br>        <span class="hljs-comment">//register</span><br>        registerReceiver(myReceiver, intentFilter);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        unregisterReceiver(myReceiver);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 点击屏幕上按钮就会有toast:”button is clicked it has sent a broad cast”这样就完成了一次send + receive 的完整操作。注意这里的广播其他应用也是可以接收的，要发送其他应用无法接收的需要本底广播，详见下篇。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小记</title>
    <link href="/posts/db80/"/>
    <url>/posts/db80/</url>
    
    <content type="html"><![CDATA[<h2 id="小记——博客开篇"><a href="#小记——博客开篇" class="headerlink" title="小记——博客开篇"></a>小记——博客开篇</h2><p>这是博客的第一篇文章，工科生文笔着实不好。望见谅。<br>这个小博客仅供自己记录和学习使用，故没有增加评论和阅读次数统计功能。你若看见了便是缘分，能从中学习知识甚至找到共鸣便是我的荣幸。</p><span id="more"></span><p>我是机械设计制造及自动化专业的学生，在写这篇文章的时候也是我得知自己转专业失败的时候，内心比较复杂，但因为此也正好有话可说。</p><p>我热衷于计算机，建立这个小博客也是自己计算机之路的一个小步骤，当然转去计算机也是。当我一块砖一块砖堆砌自己的梦想的时候，最重要的一块我却未能成功搬起来，反而被它砸到了脚。在刚刚得知这个消息的时候，我的内心是崩溃的，因为我回忆自己的面试以及考试是多么顺利，然而最后结果是<strong>我没有过</strong>。我无法理解，自己到底做错了什么，内心一度郁闷。<br>  我比其他人投入的多太多，但失败时我最终没有发泄出来，我没有当愤青去抱怨这个世界的不公，而是选择平静地接受了这个事实，在旁人问起“你这么喜欢计算机为什么没有过啊？”的时候，我无法回答，只能陈述事实，没有过就是没过。不过我只能在机械这条路上走下去，从另外一个角度去探寻真理，去追寻深处所谓的“梦想”吗?</p><p>现实总是如此残酷，我也只能默默地忍受这一事实，失败就是失败，无法狡辩。然而可怕的不是失败，而是缺少面对失败的勇气。因此，在屋漏偏逢连夜雨的时候，我还是要把博客更新下去，计算机这条路也不会因此停下，共勉。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BlogText</title>
    <link href="/posts/7037/"/>
    <url>/posts/7037/</url>
    
    <content type="html"><![CDATA[<p>一篇博客测试也是markdown语法记录</p><p><code># title 1</code></p><h1 id="title-1"><a href="#title-1" class="headerlink" title="title 1"></a>title 1</h1><p><code>## title 2</code></p><h2 id="title-2"><a href="#title-2" class="headerlink" title="title 2"></a>title 2</h2><p><code>### title 3</code></p><h3 id="title-3"><a href="#title-3" class="headerlink" title="title 3"></a>title 3</h3><p><code>#### title 4</code></p><h4 id="title-4"><a href="#title-4" class="headerlink" title="title 4"></a>title 4</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">other title1</span><br><span class="hljs-section">==</span><br></code></pre></td></tr></table></figure><h1 id="other-title1"><a href="#other-title1" class="headerlink" title="other title1"></a>other title1</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">other title2</span><br><span class="hljs-section">--</span><br></code></pre></td></tr></table></figure><h2 id="other-title2"><a href="#other-title2" class="headerlink" title="other title2"></a>other title2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">1. I love my university</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">2. I like UESTC</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">frist</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;secont</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; third</span><br></code></pre></td></tr></table></figure><blockquote><ol><li>I love my university</li><li>I like UESTC</li></ol></blockquote><blockquote><p>frist</p><blockquote><p>secont</p><blockquote><p>third</p></blockquote></blockquote></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> dede<br><span class="hljs-bullet">+</span> dedef<br><span class="hljs-bullet">+</span> dewfwfwe<br></code></pre></td></tr></table></figure><ul><li>dede</li><li>dedef</li><li>dewfwfwe</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>list<br><span class="hljs-bullet">- </span>list<br><span class="hljs-bullet">- </span>list<br></code></pre></td></tr></table></figure><ul><li>list</li><li>list</li><li>list</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> list1<br><span class="hljs-bullet">2.</span> list2<br><span class="hljs-bullet">3.</span> list3<br></code></pre></td></tr></table></figure><ol><li>list1</li><li>list2</li><li>list3</li></ol><p><code>**粗体（blod）**</code></p><p><strong>粗体（blod）</strong></p><p><code>*斜体*</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>斜体</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//code</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[AgNO3&#x27;Blog]</span>(http:<span class="hljs-comment">//hhhxiao.github.io&quot;)</span><br></code></pre></td></tr></table></figure><p> <a href="http://hhhxiao.github.io"/">AgNO3’Blog</a></p><p> <code>![](https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=f4d8ab6c02f41bd5c553eef461db81a0/f9198618367adab4c32b570487d4b31c8601e4fa.jpg)</code><br><img src="https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D300/sign=f4d8ab6c02f41bd5c553eef461db81a0/f9198618367adab4c32b570487d4b31c8601e4fa.jpg"></p><p><code>数学公式$sqrt(a-b^2)$</code></p><p>数学公式$sqrt(a-b^2)$</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\int_a^b f(x)dx<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\int_a^b f(x)dx<br>$$</p><p><code>****</code>(分割线)</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">name |<span class="hljs-string"> age</span>|<br>---- |<span class="hljs-string"> ---</span>|<br>LearnShare |<span class="hljs-string"> 12</span><br><span class="hljs-string">Mike </span>|<span class="hljs-string">  32</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>age</th></tr></thead><tbody><tr><td>LearnShare</td><td>12</td></tr><tr><td>Mike</td><td>32</td></tr></tbody></table><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> left </span>|<span class="hljs-string"> center </span>|<span class="hljs-string"> right </span>|<br>|<span class="hljs-string"> :--- </span>|<span class="hljs-string"> :----: </span>|<span class="hljs-string"> ----: </span>|<br>|<span class="hljs-string"> aaaa </span>|<span class="hljs-string"> bbbbbb </span>|<span class="hljs-string"> ccccc </span>|<br>|<span class="hljs-string"> a    </span>|<span class="hljs-string"> b      </span>|<span class="hljs-string"> c     </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">left</th><th align="center">center</th><th align="right">right</th></tr></thead><tbody><tr><td align="left">aaaa</td><td align="center">bbbbbb</td><td align="right">ccccc</td></tr><tr><td align="left">a</td><td align="center">b</td><td align="right">c</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
